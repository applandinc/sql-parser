// Generated by PEG.js 0.10.0.
//
// http://pegjs.org/

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part)
              ? classEscape(part[0]) + "-" + classEscape(part[1])
              : classEscape(part);
          });

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, "\\\\")
      .replace(/"/g,  "\\\"")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, "\\\\")
      .replace(/\]/g, "\\]")
      .replace(/\^/g, "\\^")
      .replace(/-/g,  "\\-")
      .replace(/\0/g, "\\0")
      .replace(/\t/g, "\\t")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/[\x00-\x0F]/g,          function(ch) { return "\\x0" + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return "\\x"  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = expected.map(describeExpectation);
    var i, j;

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$DefaultTracer() {
  this.indentLevel = 0;
}

peg$DefaultTracer.prototype.trace = function(event) {
  var that = this;

  function log(event) {
    function repeat(string, n) {
       var result = "", i;

       for (i = 0; i < n; i++) {
         result += string;
       }

       return result;
    }

    function pad(string, length) {
      return string + repeat(" ", length - string.length);
    }

    if (typeof console === "object") {
      console.log(
        event.location.start.line + ":" + event.location.start.column + "-"
          + event.location.end.line + ":" + event.location.end.column + " "
          + pad(event.type, 10) + " "
          + repeat("  ", that.indentLevel) + event.rule
      );
    }
  }

  switch (event.type) {
    case "rule.enter":
      log(event);
      this.indentLevel++;
      break;

    case "rule.match":
      this.indentLevel--;
      log(event);
      break;

    case "rule.fail":
      this.indentLevel--;
      log(event);
      break;

    default:
      throw new Error("Invalid event type: " + event.type + ".");
  }
};

function peg$parse(input, options) {
  options = options !== undefined ? options : {};

  var peg$FAILED = {};

  var peg$startRuleIndices = { start: 0, start_streaming: 1 };
  var peg$startRuleIndex = 0;

  var peg$consts = [
    function(s) {
        return s;
      },
    function(f, b) {
        return {
          'type': 'statement',
          'variant': 'list',
          'statement': flattenAll([ f, b ])
        };
      },
    function(s) { return s; },
    peg$otherExpectation("Type Definition"),
    function(t, a) {
        return Object.assign(t, a);
      },
    function(n) {
        return {
          'type': 'datatype',
          'variant': n[0],
          'affinity': n[1]
        };
      },
    peg$otherExpectation("Custom Datatype Name"),
    function(t, r) {
        const variant = foldStringKey([ t, r ]);
        let affinity = 'numeric';
        if (/int/i.test(variant)) {
          affinity = 'integer';
        } else if (/char|clob|text/i.test(variant)) {
          affinity = 'text';
        } else if (/blob/i.test(variant)) {
          affinity = 'blob';
        } else if (/real|floa|doub/i.test(variant)) {
          affinity = 'real';
        }
        return {
          'type': 'datatype',
          'variant': variant,
          'affinity': affinity
        };
      },
    /^[\t ]/,
    peg$classExpectation(["\t", " "], false, false),
    function(w) {
        return w;
      },
    peg$otherExpectation("Type Definition Arguments"),
    function(a1, a2) {
        return {
          'args': {
            'type': 'expression',
            'variant': 'list',
            'expression': flattenAll([ a1, a2 ])
          }
        };
      },
    function(n) { return n; },
    peg$otherExpectation("Null Literal"),
    function(n) {
        return {
          'type': 'literal',
          'variant': 'null',
          'value': keyNode(n)
        };
      },
    peg$otherExpectation("Date Literal"),
    function(d) {
        return {
          'type': 'literal',
          'variant': 'date',
          'value': keyNode(d)
        };
      },
    peg$otherExpectation("String Literal"),
    function(n, s) {
        return {
          'type': 'literal',
          'variant': 'text',
          'value': s
        };
      },
    peg$otherExpectation("Single-quoted String Literal"),
    function(s) {
        /**
         * @note Unescaped the pairs of literal single quotation marks
         */
        /**
         * @note Not sure if the BLOB type should be un-escaped
         */
        return unescape(s, "'");
      },
    "''",
    peg$literalExpectation("''", false),
    /^[^']/,
    peg$classExpectation(["'"], true, false),
    peg$otherExpectation("Blob Literal"),
    /^[x]/i,
    peg$classExpectation(["x"], false, true),
    function(b) {
        return {
          'type': 'literal',
          'variant': 'blob',
          'value': b
        };
      },
    peg$otherExpectation("Typed literal (or bind parameter)"),
    function(t, s) {
        return {
          type: 'expression',
          format: 'unary',
          variant: 'cast',
          expression: s,
          as: t
        };
      },
    function(n) {
        return {
          'type': 'literal',
          'variant': 'text',
          'value': n
        };
      },
    peg$otherExpectation("Number Sign"),
    function(s, n) {
        if (isOkay(s)) {
          n['value'] = foldStringWord([ s, n['value'] ]);
        }
        return n;
      },
    function(d, e) {
        return {
          'type': 'literal',
          'variant': 'decimal',
          'value': foldStringWord([ d, e ])
        };
      },
    peg$otherExpectation("Decimal Literal"),
    function(f, b) { return foldStringWord([ f, b ]); },
    function(t, d) { return foldStringWord([ t, d ]); },
    peg$otherExpectation("Decimal Literal Exponent"),
    "e",
    peg$literalExpectation("E", true),
    /^[+\-]/,
    peg$classExpectation(["+", "-"], false, false),
    function(e, s, d) { return foldStringWord([ e, s, d ]); },
    peg$otherExpectation("Hexidecimal Literal"),
    "0x",
    peg$literalExpectation("0x", true),
    function(f, b) {
        return {
          'type': 'literal',
          'variant': 'hexidecimal',
          'value': foldStringWord([ f, b ])
        };
      },
    /^[0-9a-f]/i,
    peg$classExpectation([["0", "9"], ["a", "f"]], false, true),
    /^[0-9]/,
    peg$classExpectation([["0", "9"]], false, false),
    peg$otherExpectation("Bind Parameter"),
    function(b) {
        return Object.assign({
          'type': 'variable'
        }, b);
      },
    peg$otherExpectation("Numbered Bind Parameter"),
    function(q, id) {
        return {
          'format': 'numbered',
          'name': foldStringWord([ q, id ])
        };
      },
    /^[1-9]/,
    peg$classExpectation([["1", "9"]], false, false),
    function(f, r) {
        return foldStringWord([ f, r ]);
      },
    peg$otherExpectation("Named Bind Parameter"),
    /^[:@]/,
    peg$classExpectation([":", "@"], false, false),
    function(s, name) {
        return {
          'format': 'named',
          'name': foldStringWord([ s, name ])
        };
      },
    peg$otherExpectation("TCL Bind Parameter"),
    "$",
    peg$literalExpectation("$", false),
    ":",
    peg$literalExpectation(":", false),
    function(d, name, s) {
        return Object.assign({
          'format': 'tcl',
          'name': foldStringWord([ d, name ])
        }, s);
      },
    function(sfx) {
        return {
          'suffix': sfx
        };
      },
    peg$otherExpectation("EXISTS Expression"),
    function(n, e) {
        if (isOkay(n)) {
          return {
            'type': 'expression',
            'format': 'unary',
            'variant': 'exists',
            'expression': e,
            'operator': keyNode(n)
          };
        }
        return e;
      },
    peg$otherExpectation("EXISTS Keyword"),
    function(n, x) { return foldStringKey([ n, x ]); },
    peg$otherExpectation("RAISE Expression"),
    function(s, a) {
        return Object.assign({
          'type': 'expression',
          'format': 'unary',
          'variant': keyNode(s),
          'expression': a
        }, a);
      },
    peg$otherExpectation("RAISE Expression Arguments"),
    function(a) {
        return Object.assign({
          'type': 'error'
        }, a);
      },
    peg$otherExpectation("IGNORE Keyword"),
    function(f) {
        return {
          'action': keyNode(f)
        };
      },
    function(f, m) {
        return {
          'action': keyNode(f),
          'message': m
        };
      },
    function(n) {
        return n;
      },
    function(e, c) {
        return Object.assign(c, {
          'expression': e
        });
      },
    peg$otherExpectation("PSQL-style cast"),
    "::",
    peg$literalExpectation("::", false),
    function(e, d) {
        return {
          'type': 'expression',
          'format': 'unary',
          'variant': 'cast',
          'expression': e,
          'as': d
        };
      },
    function(op, e) {
        return {
          'type': 'expression',
          'format': 'unary',
          'variant': 'operation',
          'expression': e,
          'operator': keyNode(op)
        };
      },
    peg$otherExpectation("COLLATE Expression"),
    function(c) {
        return Object.assign({
          'type': 'expression',
          'format': 'unary',
          'variant': 'operation',
          'operator': 'collate'
        }, c);
      },
    function(f, rest) { return composeBinary(f, rest); },
    function(i) {
        return [null, i, null, {
          'type': 'literal',
          'variant': 'null',
          'value': 'null'
        }];
      },
    "not ",
    peg$literalExpectation("NOT ", true),
    "null",
    peg$literalExpectation("NULL", true),
    function() { return 'not'; },
    function() { return 'is'; },
    peg$otherExpectation("CAST Expression"),
    function(s, e, a) {
        return {
          'type': 'expression',
          'format': 'unary',
          'variant': keyNode(s),
          'expression': e,
          'as': a
        };
      },
    peg$otherExpectation("Type Alias"),
    function(d) { return d; },
    peg$otherExpectation("CASE Expression"),
    function(t, e, w, s) {
        return Object.assign({
          'type': 'expression',
          'variant': keyNode(t),
          'expression': flattenAll([ w, s ])
        }, e);
      },
    function(e) {
        return {
          'discriminant': e
        };
      },
    peg$otherExpectation("WHEN Clause"),
    function(s, w, t) {
        return {
          'type': 'condition',
          'variant': keyNode(s),
          'condition': w,
          'consequent': t
        };
      },
    peg$otherExpectation("ELSE Clause"),
    function(s, e) {
        return {
          'type': 'condition',
          'variant': keyNode(s),
          'consequent': e
        };
      },
    function(v, p) {
        return Object.assign(p, {
          'left': v
        });
      },
    peg$otherExpectation("IS DISTINCT expression"),
    function(n, m, e) {
          return {
            type: 'expression',
            format: 'binary',
            variant: 'operation',
            operation: foldStringKey([ n, m ]),
            right: e
          };
        },
    peg$otherExpectation("Comparison Expression"),
    function(n, m, e, x) {
        return Object.assign({
          'type': 'expression',
          'format': 'binary',
          'variant': 'operation',
          'operation': foldStringKey([ n, m ]),
          'right': e
        }, x);
      },
    peg$otherExpectation("ESCAPE Expression"),
    function(s, e) {
        return {
          'escape': e
        };
      },
    peg$otherExpectation("BETWEEN Expression"),
    function(n, b, tail) {
        return {
          'type': 'expression',
          'format': 'binary',
          'variant': 'operation',
          'operation': foldStringKey([ n, b ]),
          'right': tail
        };
      },
    function(f, rest) { return composeBinary(f, [ rest ]); },
    function(n) { return keyNode(n); },
    peg$otherExpectation("IN Expression"),
    function(n, i, e) {
        return {
          'type': 'expression',
          'format': 'binary',
          'variant': 'operation',
          'operation': foldStringKey([ n, i ]),
          'right': e
        };
      },
    function(e) { return e; },
    peg$otherExpectation("Expression List"),
    function(l) {
        return {
          'type': 'expression',
          'variant': 'list',
          'expression': isOkay(l) ? l : []
        };
      },
    function(f, rest) {
        return flattenAll([ f, rest ]);
      },
    peg$otherExpectation("Function Call"),
    function(n, a, o) {
        return Object.assign({
          'type': 'function',
          'name': n
        }, a, o);
      },
    peg$otherExpectation("Function Call Arguments"),
    function(s) {
        return {
          'args': {
            'type': 'identifier',
            'variant': 'star',
            'name': s
          }
        };
      },
    function(d, e) {
        return !isOkay(d) || e['expression'].length > 0;
      },
    function(d, e) {
        return {
          'args': Object.assign(e, d)
        };
      },
    function(s) {
        return {
          'filter': keyNode(s)
        };
      },
    peg$otherExpectation("OVER clause"),
    function(w) {
        return {
          over: w
        };
      },
    peg$otherExpectation("Window name"),
    function(n) {
        return {
          'type': 'identifier',
          'variant': 'window',
          'name': n
        };
      },
    peg$otherExpectation("Window specification"),
    function(w, p, o) {
        return Object.assign({
          type: 'window'
        }, w, p, o);
      },
    function(n) {
        return {
          source: n
        };
      },
    peg$otherExpectation("window partition clause"),
    function(e) {
        return {
          partition: e
        };
      },
    peg$otherExpectation("Error Message"),
    function(m) { return m; },
    peg$otherExpectation("Statement"),
    function(m, s) {
        return Object.assign(s, m);
      },
    peg$otherExpectation("QUERY PLAN"),
    function(e, q) {
        return {
          'explain': isOkay(e)
        };
      },
    peg$otherExpectation("QUERY PLAN Keyword"),
    function(q, p) { return foldStringKey([ q, p ]); },
    peg$otherExpectation("END Transaction Statement"),
    function(s, t) {
        return {
          'type': 'statement',
          'variant': 'transaction',
          'action': 'commit'
        };
      },
    peg$otherExpectation("BEGIN Transaction Statement"),
    function(s, m, t, n) {
        return Object.assign({
          'type': 'statement',
          'variant': 'transaction',
          'action': 'begin'
        }, m, n);
      },
    function(t) { return t; },
    function(m) {
        return {
          'defer': keyNode(m)
        };
      },
    peg$otherExpectation("ROLLBACK Statement"),
    function(s, n) {
        return Object.assign({
          'type': 'statement',
          'variant': 'transaction',
          'action': 'rollback'
        }, n);
      },
    peg$otherExpectation("TO Clause"),
    function(n) {
        return {
          'savepoint': n
        }
      },
    function(s) { return keyNode(s); },
    peg$otherExpectation("SAVEPOINT Statement"),
    function(s, n) {
        return {
          'type': 'statement',
          'variant': s,
          'target': n
        };
      },
    peg$otherExpectation("RELEASE Statement"),
    function(s, a, n) {
        return {
          'type': 'statement',
          'variant': keyNode(s),
          'target': n
        };
      },
    peg$otherExpectation("ALTER TABLE Statement"),
    function(s, n, e) {
        return Object.assign({
          'type': 'statement',
          'variant': keyNode(s),
          'target': n
        }, e);
      },
    peg$otherExpectation("ALTER TABLE Keyword"),
    function(a, t) { return foldStringKey([ a, t ]); },
    peg$otherExpectation("RENAME TO Keyword"),
    function(s, n) {
        return {
          'action': keyNode(s),
          'name': n
        };
      },
    peg$otherExpectation("ADD COLUMN Keyword"),
    function(s, d) {
        return {
          'action': keyNode(s),
          'definition': d
        };
      },
    function(w, s) { return Object.assign(s, w); },
    peg$otherExpectation("WITH Clause"),
    function(s, v, t) {
        var recursive = {
          'variant': isOkay(v) ? 'recursive' : 'common'
        };
        if (isArrayOkay(t)) {
          // Add 'recursive' property into each table expression
          t = t.map(function (elem) {
            return Object.assign(elem, recursive);
          });
        }
        return {
          'with': t
        };
      },
    function(f, r) { return flattenAll([ f, r ]); },
    peg$otherExpectation("Common Table Expression"),
    function(t, s) {
        return Object.assign({
          'type': 'expression',
          'format': 'table',
          'variant': 'common',
          'target': t
        }, s);
      },
    function(s) {
        return {
          'expression': s
        };
      },
    function(w, s) {
        return Object.assign(s, w);
      },
    function(t) {
        return {
          type: 'statement',
          variant: 'show',
          target: t
        };
      },
    "time",
    peg$literalExpectation("TIME", true),
    "zone",
    peg$literalExpectation("ZONE", true),
    function() {
        return {
          type: 'identifier',
          variant: 'variable',
          name: 'timezone'
        };
      },
    "transaction",
    peg$literalExpectation("TRANSACTION", true),
    "isolation",
    peg$literalExpectation("ISOLATION", true),
    "level",
    peg$literalExpectation("LEVEL", true),
    function() {
        return {
          type: 'identifier',
          variant: 'variable',
          name: 'transaction_isolation'
        };
      },
    "session",
    peg$literalExpectation("SESSION", true),
    "authorization",
    peg$literalExpectation("AUTHORIZATION", true),
    function() {
        return {
          type: 'identifier',
          variant: 'variable',
          name: 'session_authorization'
        };
      },
    "all",
    peg$literalExpectation("ALL", true),
    function() {
        return {
          type: 'identifier',
          variant: 'variable',
          name: 'all'
        };
      },
    peg$otherExpectation("ATTACH Statement"),
    function(a, b, e, n) {
        return {
          'type': 'statement',
          'variant': keyNode(a),
          'target': n,
          'attach': e
        };
      },
    peg$otherExpectation("DETACH Statement"),
    function(d, b, n) {
        return {
          'type': 'statement',
          'variant': keyNode(d),
          'target': n
        };
      },
    peg$otherExpectation("VACUUM Statement"),
    function(v, t) {
        return Object.assign({
          'type': 'statement',
          'variant': 'vacuum'
        }, t);
      },
    function(t) {
        return {
          'target': t
        };
      },
    peg$otherExpectation("ANALYZE Statement"),
    function(s, a) {
        return Object.assign({
          'type': 'statement',
          'variant': keyNode(s)
        }, a);
      },
    function(n) {
        return {
          'target': n['name']
        };
      },
    peg$otherExpectation("REINDEX Statement"),
    function(a) {
        return {
          'target': a['name']
        };
      },
    peg$otherExpectation("PRAGMA Statement"),
    function(s, n, v) {
        return {
          'type': 'statement',
          'variant': keyNode(s),
          'target': n,
          'args': {
            'type': 'expression',
            'variant': 'list',
            'expression': v
          }
        };
      },
    function(v) { return v; },
    function(v) { return /^(yes|no|on|off|false|true|0|1)$/i.test(v) },
    function(v) {
        return {
          'type': 'literal',
          'variant': 'boolean',
          'normalized': (/^(yes|on|true|1)$/i.test(v) ? '1' : '0'),
          'value': v
        };
      },
    function(n) {
        return keyNode(n);
      },
    function(n) {
        return {
          'type': 'identifier',
          'variant': 'name',
          'name': n
        };
      },
    peg$otherExpectation("SELECT Statement"),
    function(s, o, l, f) {
        return Object.assign(s, o, l, f);
      },
    function(s, o, f, l) {
        return Object.assign(s, o, l, f);
      },
    peg$otherExpectation("SELECT ... FOR locking clause"),
    function() { return {}; },
    function(i, r) { return { locking: flattenAll([ i, r ]) }; },
    function(i) { return i; },
    function(s, r, n) {
        return Object.assign({
          type: 'expression',
          variant: 'locking',
          strength: foldStringWord(s).toLowerCase()
        }, r, n);
      },
    function(l) {
        return {
          target: l
        };
      },
    function(i, r) { return flattenAll([ i, r ]); },
    function(p) {
        return { policy: foldStringWord(p).toLowerCase() };
      },
    peg$otherExpectation("WINDOW clause"),
    function(l) {
        return {
          window: l
        };
      },
    function(n, d) {
        return Object.assign(d, {
          target: n
        });
      },
    peg$otherExpectation("ORDER BY Clause"),
    function(d) {
        return {
          'order': d['result']
        };
      },
    peg$otherExpectation("LIMIT Clause"),
    function(s, e, d) {
        return {
          'limit': Object.assign({
            'type': 'expression',
            'variant': 'limit',
            'start': e
          }, d)
        };
      },
    peg$otherExpectation("OFFSET Clause"),
    function(o, e) {
        return {
          'offset': e
        };
      },
    function(s, u) {
        if (isArrayOkay(u)) {
          return {
            'type': 'statement',
            'variant': 'compound',
            'statement': s,
            'compound': u
          };
        } else {
          return s;
        }
      },
    peg$otherExpectation("Union Operation"),
    function(c, s) {
        return {
          'type': 'compound',
          'variant': c,
          'statement': s
        };
      },
    function(s, f, w, g, i) {
        return Object.assign({
          'type': 'statement',
          'variant': 'select',
        }, s, f, w, g, i);
      },
    peg$otherExpectation("SELECT Results Clause"),
    function(d, t) {
        return Object.assign({
          'result': t
        }, d);
      },
    peg$otherExpectation("SELECT Results Modifier"),
    function(s) {
        return {
          'distinct': true
        };
      },
    function(s) {
        return {};
      },
    peg$otherExpectation("FROM Clause"),
    function(f, s) {
        return {
          'from': s
        };
      },
    peg$otherExpectation("WHERE Clause"),
    function(f, e) {
        return {
          'where': makeArray(e)
        };
      },
    peg$otherExpectation("GROUP BY Clause"),
    function(f, e, h) {
        return Object.assign({
          'group': e
        }, h);
      },
    peg$otherExpectation("HAVING Clause"),
    function(f, e) {
        return {
          'having': e
        };
      },
    function(q, s) {
        return {
          'type': 'identifier',
          'variant': 'star',
          'name': foldStringWord([ q, s ])
        };
      },
    function(n, s) { return foldStringWord([ n, s ]); },
    function(e, a) {
        return Object.assign(e, a);
      },
    function(f, t) {
        if (isArrayOkay(t)) {
          return {
            'type': 'map',
            'variant': 'join',
            'source': f,
            'map': t
          };
        }
        return f;
      },
    function(cl, c) {
        return Object.assign(cl, c);
      },
    peg$otherExpectation("CROSS JOIN Operation"),
    function(n) {
        return {
          'type': 'join',
          'variant': 'cross join',
          'source': n
        };
      },
    peg$otherExpectation("JOIN Operation"),
    function(o, n) {
        return {
          'type': 'join',
          'variant': keyNode(o),
          'source': n
        };
      },
    function(l, t) {
        return Object.assign(t, l);
      },
    function(n, l, a) {
        return Object.assign({
          'type': 'function',
          'variant': 'table',
          'name': n,
          'args': l
        }, a);
      },
    function(n, c) { return { alias: n, columns: c }; },
    function(c) { return { columns: c }; },
    function(f, b) { return flattenAll([ f, b ]); },
    function(n, t, c) {
        return Object.assign({
          type: 'definition',
          variant: 'column',
          name: n,
          datatype: t
        }, c);
      },
    function() {
        return { lateral: true };
      },
    peg$otherExpectation("Qualified Table"),
    function(d, i) {
        return Object.assign(d, i);
      },
    peg$otherExpectation("Qualified Table Identifier"),
    function(n, a) {
        return Object.assign(n, a);
      },
    peg$otherExpectation("Qualfied Table Index"),
    function(s, n) {
        return {
          'index': n
        };
      },
    function(n, i) {
        // TODO: Not sure what should happen here
        return {
          'index': foldStringKey([ n, i ])
        };
      },
    peg$otherExpectation("SELECT Source"),
    function(l, a) { return Object.assign(l, a); },
    peg$otherExpectation("Subquery"),
    function(s, a) {
        return Object.assign(s, a);
      },
    peg$otherExpectation("Alias"),
    function(a, n) {
        return {
          'alias': n
        };
      },
    peg$otherExpectation("JOIN Operator"),
    function(n, t, j) { return foldStringKey([ n, t, j ]); },
    function(t, o) { return foldStringKey([ t, o ]); },
    function(t) { return keyNode(t); },
    peg$otherExpectation("JOIN Constraint"),
    function(c) {
        return {
          'constraint': Object.assign({
            'type': 'constraint',
            'variant': 'join'
          }, c)
        }
      },
    peg$otherExpectation("Join ON Clause"),
    function(s, e) {
        return {
          'format': keyNode(s),
          'on': e
        };
      },
    peg$otherExpectation("Join USING Clause"),
    function(s, e) {
        return {
          'format': keyNode(s),
          'using': e
        };
      },
    peg$otherExpectation("VALUES Clause"),
    function(s, l) {
        return {
          'type': 'statement',
          'variant': 'select',
          'result': l
        };
      },
    function(f, b) {
        return {
          'result': flattenAll([ f, b ])
        };
      },
    peg$otherExpectation("Ordering Expression"),
    function(e, d, n) {
        // Only convert this into an ordering expression if it contains
        // more than just the expression.
        if (isOkay(d) || isOkay(n)) {
          return Object.assign({
            'type': 'expression',
            'variant': 'order',
            'expression': e
          }, d, n);
        }
        return e;
      },
    function(d) {
        return {
          nulls: keyNode(d)
        };
      },
    peg$otherExpectation("Star"),
    peg$otherExpectation("Fallback Type"),
    peg$otherExpectation("INSERT Statement"),
    function(k, t, c, r) {
        return Object.assign({
          'type': 'statement',
          'variant': 'insert'
        }, k, t, c, r);
      },
    peg$otherExpectation("RETURNING clause"),
    function(t) {
        return {
          returning: t
        };
      },
    peg$otherExpectation("INSERT Keyword"),
    function(a, m) {
        return Object.assign({
          'action': keyNode(a)
        }, m);
      },
    peg$otherExpectation("REPLACE Keyword"),
    function(a) {
        return {
          'action': keyNode(a)
        };
      },
    peg$otherExpectation("INSERT OR Modifier"),
    function(s, m) {
        return {
          'or': keyNode(m)
        };
      },
    function(i, r) {
        return Object.assign({
          'into': i
        }, r);
      },
    peg$otherExpectation("INTO Clause"),
    function(s, t) {
        return t;
      },
    peg$otherExpectation("INTO Keyword"),
    function(r) {
        return {
          'result': r
        };
      },
    peg$otherExpectation("PostgreSQL INSERT ON CONFLICT clause"),
    "do",
    peg$literalExpectation("DO", true),
    function(i, a) {
        return {
          conflict: Object.assign(a, i)
        };
      },
    peg$otherExpectation("PostgreSQL ON CONFLICT action"),
    function(s, t, w) {
        return Object.assign({
          action: s
        }, t, w);
      },
    "nothing",
    peg$literalExpectation("NOTHING", true),
    function(s) {
        return {
          action: keyNode(s)
        };
      },
    peg$otherExpectation("PostgreSQL ON CONFLICT expression"),
    function(i, w) {
        return { on: Object.assign({columns: i}, w) };
      },
    function(c) {
        return { on: {
          constraint: c
        }};
      },
    peg$otherExpectation("Column List"),
    function(f, b) {
        return {
          'columns': flattenAll([ f, b ])
        };
      },
    function(c) { return c; },
    peg$otherExpectation("Column Name"),
    function(n) {
        return {
          'type': 'identifier',
          'variant': 'column',
          'name': n
        };
      },
    function(s, r) { return r; },
    peg$otherExpectation("VALUES Keyword"),
    peg$otherExpectation("Wrapped Expression List"),
    function(e) {
        return e;
      },
    peg$otherExpectation("DEFAULT VALUES Clause"),
    function(d, v) {
        return {
          'type': 'values',
          'variant': 'default'
          // TODO: Not sure what should go here
          // , 'values': null
        };
      },
    peg$otherExpectation("Compound Operator"),
    peg$otherExpectation("UNION Operator"),
    function(s, a) { return foldStringKey([ s, a ]); },
    function(a) { return a; },
    peg$otherExpectation("UPDATE Statement"),
    function(s, f, t, u, w, o, l, r) {
        return Object.assign({
          'type': 'statement',
          'variant': s,
          'into': t
        }, f, u, w, o, l, r);
      },
    peg$otherExpectation("UPDATE Keyword"),
    peg$otherExpectation("UPDATE OR Modifier"),
    function(t) {
        return {
          'or': keyNode(t)
        };
      },
    peg$otherExpectation("SET Clause"),
    function(c) {
        return {
          'set': c
        };
      },
    peg$otherExpectation("Column Assignment"),
    function(f, e) {
        return {
          'type': 'assignment',
          'target': f,
          'value': e
        };
      },
    peg$otherExpectation("UPDATE value expression"),
    function() {
        return {
          type: 'literal',
          variant: 'default',
          value: 'default'
        };
      },
    peg$otherExpectation("DELETE Statement"),
    function(s, t, w, o, l, r) {
        return Object.assign({
          'type': 'statement',
          'variant': s,
          'from': t
        }, w, o, l, r);
      },
    peg$otherExpectation("DELETE Keyword"),
    peg$otherExpectation("CREATE Statement"),
    peg$otherExpectation("CREATE TABLE Statement"),
    function(s, ne, id, r) {
        return Object.assign({
          'type': 'statement',
          'name': id
        }, s, r, ne);
      },
    function(s, tmp, t) {
        return Object.assign({
          'variant': s,
          'format': keyNode(t)
        }, tmp);
      },
    function(t) {
        return {
          'temporary': isOkay(t)
        };
      },
    peg$otherExpectation("IF NOT EXISTS Modifier"),
    function(i, n, e) {
        return {
          'condition': makeArray({
            'type': 'condition',
            'variant': keyNode(i),
            'condition': {
              'type': 'expression',
              'variant': keyNode(e),
              'operator': foldStringKey([ n, e ])
            }
          })
        };
      },
    peg$otherExpectation("Table Definition"),
    function(s, t, r) {
        return Object.assign({
          'definition': flattenAll([ s, t ])
        }, r);
      },
    function(r, w) {
        return {
          'optimization': [{
            'type': 'optimization',
            'value': foldStringKey([ r, w ])
          }]
        };
      },
    function(f) { return f; },
    peg$otherExpectation("Column Definition"),
    function(n, t, c) {
        return Object.assign({
          'type': 'definition',
          'variant': 'column',
          'name': n,
          'definition': (isOkay(c) ? c : []),
        }, t);
      },
    peg$otherExpectation("Column Datatype"),
    function(t) {
        return {
          'datatype': t
        };
      },
    peg$otherExpectation("Column Constraint"),
    function(n, c, ln) {
        return Object.assign(c, n);
      },
    function(cl) {
        return cl[cl.length - 1];
      },
    peg$otherExpectation("CONSTRAINT Name"),
    function(n) {
        return {
          'name': n
        };
      },
    peg$otherExpectation("FOREIGN KEY Column Constraint"),
    function(f) {
        return Object.assign({
          'variant': 'foreign key'
        }, f);
      },
    peg$otherExpectation("PRIMARY KEY Column Constraint"),
    function(p, d, c, a) {
        return Object.assign(p, c, d, a);
      },
    peg$otherExpectation("PRIMARY KEY Keyword"),
    function(s, k) {
        return {
          'type': 'constraint',
          'variant': foldStringKey([ s, k ])
        };
      },
    peg$otherExpectation("AUTOINCREMENT Keyword"),
    function(a) {
        return {
          'autoIncrement': true
        };
      },
    function(s, c) {
        return Object.assign({
          'type': 'constraint',
          'variant': s
        }, c);
      },
    peg$otherExpectation("UNIQUE Column Constraint"),
    peg$otherExpectation("NULL Column Constraint"),
    function(n, l) { return foldStringKey([ n, l ]); },
    peg$otherExpectation("CHECK Column Constraint"),
    peg$otherExpectation("DEFAULT Column Constraint"),
    function(s, v) {
        return {
          'type': 'constraint',
          'variant': keyNode(s),
          'value': v
        };
      },
    peg$otherExpectation("COLLATE Column Constraint"),
    function(c) {
        return {
          'type': 'constraint',
          'variant': 'collate',
          'collate': c
        };
      },
    peg$otherExpectation("Table Constraint"),
    function(n, c, nl) {
        return Object.assign({
          'type': 'definition',
          'variant': 'constraint'
        }, c, n);
      },
    peg$otherExpectation("CHECK Table Constraint"),
    function(c) {
        return {
          'definition': makeArray(c)
        };
      },
    peg$otherExpectation("PRIMARY KEY Table Constraint"),
    function(k, c, t) {
        return {
          'definition': makeArray(Object.assign(k, t, c[1])),
          'columns': c[0]
        };
      },
    function(s) {
        return {
          'type': 'constraint',
          'variant': keyNode(s)
        };
      },
    function(p, k) { return foldStringKey([ p, k ]); },
    peg$otherExpectation("UNIQUE Keyword"),
    function(u) { return keyNode(u); },
    function(f, b) {
        return [f].concat(b);
      },
    function(c) {
        return c.map(([ res ]) => res);
      },
    function(c) {
        const auto = c.find(([ res, a ]) => isOkay(a));
        return [
          c.map(([ res, a ]) => res),
          auto ? auto[1] : null
        ];
      },
    peg$otherExpectation("Indexed Column"),
    function(e, d, a) {
        // Only convert this into an ordering expression if it contains
        // more than just the expression.
        let res = e;
        if (isOkay(d)) {
          res = Object.assign({
            'type': 'expression',
            'variant': 'order',
            'expression': e
          }, d);
        }
        return [ res, a ];
      },
    peg$otherExpectation("Collation"),
    function(c) {
        return {
          'collate': makeArray(c)
        };
      },
    peg$otherExpectation("Column Direction"),
    function(t) {
        return {
          'direction': keyNode(t),
        };
      },
    function(s, t) {
        return {
          'conflict': keyNode(t)
        };
      },
    peg$otherExpectation("ON CONFLICT Keyword"),
    function(o, c) { return foldStringKey([ o, c ]); },
    function(k, c) {
        return {
          'type': 'constraint',
          'variant': keyNode(k),
          'expression': c
        };
      },
    peg$otherExpectation("FOREIGN KEY Table Constraint"),
    function(k, l, c) {
        return Object.assign({
          'definition': makeArray(Object.assign(k, c))
        }, l);
      },
    peg$otherExpectation("FOREIGN KEY Keyword"),
    function(f, k) {
        return {
          'type': 'constraint',
          'variant': foldStringKey([ f, k ])
        };
      },
    function(r, a, d) {
        return Object.assign({
          'type': 'constraint'
        }, r, a, d);
      },
    peg$otherExpectation("REFERENCES Clause"),
    function(s, t) {
        return {
          'references': t
        };
      },
    function(f, b) {
        return {
          'action': flattenAll([ f, b ])
        };
      },
    peg$otherExpectation("FOREIGN KEY Action Clause"),
    function(m, a, n) {
        return {
          'type': 'action',
          'variant': keyNode(m),
          'action': keyNode(n)
        };
      },
    peg$otherExpectation("FOREIGN KEY Action"),
    function(s, v) { return foldStringKey([ s, v ]); },
    function(c) { return keyNode(c); },
    function(n, a) { return foldStringKey([ n, a ]); },
    function(m, n) {
        return {
          'type': 'action',
          'variant': keyNode(m),
          'action': n
        };
      },
    peg$otherExpectation("DEFERRABLE Clause"),
    function(n, d, i) {
        return {
          'defer': foldStringKey([ n, d, i ])
        };
      },
    function(i, d) { return foldStringKey([ i, d ]); },
    function(s) {
        return {
          'definition': makeArray(s)
        };
      },
    peg$otherExpectation("CREATE INDEX Statement"),
    function(s, ne, n, o, w) {
        return Object.assign({
          'type': 'statement',
          'target': n,
          'on': o,
        }, s, ne, w);
      },
    function(s, u, i) {
        return Object.assign({
          'variant': keyNode(s),
          'format': keyNode(i)
        }, u);
      },
    function(u) {
        return {
          'unique': true
        };
      },
    peg$otherExpectation("ON Clause"),
    function(o, t, c) {
        return {
          'type': 'identifier',
          'variant': 'expression',
          'format': 'table',
          'name': t['name'],
          'columns': c
        };
      },
    peg$otherExpectation("CREATE TRIGGER Statement"),
    function(s, ne, n, cd, o, me, wh, a) {
        return Object.assign({
          'type': 'statement',
          'target': n,
          'on': o,
          'event': cd,
          'by': (isOkay(me) ? me : 'row'),
          'action': makeArray(a)
        }, s, ne, wh);
      },
    function(s, tmp, t) {
        return Object.assign({
          'variant': keyNode(s),
          'format': keyNode(t)
        }, tmp);
      },
    peg$otherExpectation("Conditional Clause"),
    function(m, d) {
        return Object.assign({
          'type': 'event'
        }, m, d);
      },
    function(m) {
        return {
          'occurs': keyNode(m)
        };
      },
    function(i, o) { return foldStringKey([ i, o ]); },
    peg$otherExpectation("Conditional Action"),
    function(o) {
        return {
          'event': keyNode(o)
        };
      },
    function(s, f) {
        return {
          'event': keyNode(s),
          'of': f
        };
      },
    function(s, c) { return c; },
    "statement",
    peg$literalExpectation("STATEMENT", true),
    function(f, e, r) { return keyNode(r); },
    function(w, e) {
        return {
          'when': e
        };
      },
    peg$otherExpectation("Actions Clause"),
    function(s, a, e) { return a; },
    function(l) { return l; },
    peg$otherExpectation("CREATE VIEW Statement"),
    function(s, ne, n, r) {
        return Object.assign({
          'type': 'statement',
          'target': n,
          'result': r
        }, s, ne);
      },
    function(n, a) {
        return Object.assign({
          'type': 'identifier',
          'variant': 'expression',
          'format': 'view',
          'name': n['name'],
          'columns': []
        }, a);
      },
    function(s, tmp, v) {
        return Object.assign({
          'variant': keyNode(s),
          'format': keyNode(v)
        }, tmp);
      },
    peg$otherExpectation("CREATE VIRTUAL TABLE Statement"),
    function(s, ne, n, m) {
        return Object.assign({
          'type': 'statement',
          'target': n,
          'result': m
        }, s, ne);
      },
    function(s, v, t) {
        return {
          'variant': keyNode(s),
          'format': keyNode(v)
        };
      },
    function(m, a) {
        return Object.assign({
          'type': 'module',
          'variant': 'virtual',
          'name': m
        }, a);
      },
    peg$otherExpectation("Module Arguments"),
    function(l) {
        return {
          'args': {
            'type': 'expression',
            'variant': 'list',
            'expression': isOkay(l) ? l : []
          }
        };
      },
    function(f, b) {
        return flattenAll([ f, b ]).filter((arg) => isOkay(arg));
      },
    function(a) {
        return a;
      },
    peg$otherExpectation("DROP Statement"),
    function(s, q) {
        /**
         * @note Manually copy in the correct variant for the target
         */
        return Object.assign({
          'type': 'statement',
          'target': Object.assign(q, {
                      'variant': s['format']
                    })
        }, s);
      },
    peg$otherExpectation("DROP Keyword"),
    function(s, t, i) {
         return Object.assign({
           'variant': keyNode(s),
           'format': t,
           'condition': []
         }, i);
      },
    peg$otherExpectation("DROP Type"),
    peg$otherExpectation("IF EXISTS Keyword"),
    function(i, e) {
        return {
          'condition': [{
            'type': 'condition',
            'variant': keyNode(i),
            'condition': {
              'type': 'expression',
              'variant': keyNode(e),
              'operator': keyNode(e)
            }
          }]
        };
      },
    peg$otherExpectation("Or"),
    peg$otherExpectation("Add"),
    peg$otherExpectation("Subtract"),
    peg$otherExpectation("Multiply"),
    peg$otherExpectation("Divide"),
    peg$otherExpectation("Modulo"),
    peg$otherExpectation("Shift Left"),
    peg$otherExpectation("Shift Right"),
    peg$otherExpectation("Logical AND"),
    peg$otherExpectation("Logical OR"),
    peg$otherExpectation("Less Than"),
    peg$otherExpectation("Greater Than"),
    peg$otherExpectation("Less Than Or Equal"),
    peg$otherExpectation("Greater Than Or Equal"),
    peg$otherExpectation("Equal"),
    peg$otherExpectation("Not Equal"),
    peg$otherExpectation("PostgreSQL custom binary operarator"),
    function(s) {
        const sym = s.join('');
        if (sym.includes('--') || sym.includes('/*')) return false;
        const last = s[s.length-1];
        if (!(last === '-' || last === '+')) return true;
        return sym.match(/[~@#%^&|`?]/);
      },
    function(s) { return s.join(''); },
    peg$otherExpectation("IS"),
    function(i, n) { return foldStringKey([ i, n ]); },
    peg$otherExpectation("Identifier"),
    peg$otherExpectation("Database Identifier"),
    function(n) {
        return {
          'type': 'identifier',
          'variant': 'database',
          'name': n
        };
      },
    peg$otherExpectation("Function Identifier"),
    function(d, n) {
        return {
          'type': 'identifier',
          // TODO: Should this be `table function` since it is table-function name
          'variant': 'function',
          'name': foldStringWord([ d, n ])
        };
      },
    peg$otherExpectation("Table Identifier"),
    function(d, n) {
        return {
          'type': 'identifier',
          'variant': 'table',
          'name': foldStringWord([ d, n ])
        };
      },
    function(n, d) { return foldStringWord([ n, d ]); },
    peg$otherExpectation("Column Identifier"),
    function(q, n, i) {
        return Object.assign({
          'type': 'identifier',
          'variant': 'column',
          'name': foldStringWord([ q, n ])
        }, i);
      },
    peg$otherExpectation("value indirection"),
    function(l) {
        return {
          element: l
        };
      },
    function(i, r) { return flattenAll([i, r]); },
    function(n) {
        return {
          type: 'indirection',
          variant: 'attribute',
          attribute: n
        };
      },
    function(n) {
        return {
          type: 'indirection',
          variant: 'star',
          attribute: n
        };
      },
    function(l, u) {
        return Object.assign({
          type: 'indirection',
          variant: 'slice'
        }, l, u);
      },
    function(u) {
        return Object.assign({
          type: 'indirection',
          variant: 'slice'
        }, u);
      },
    function(e) {
        return {
          type: 'indirection',
          variant: 'index',
          index: e
        };
      },
    function(e) {
        return {
          lower: e
        };
      },
    function(e) {
        return {
          upper: e
        };
      },
    function() { return ''; },
    function(d, t) { return foldStringWord([ d, t ]); },
    peg$otherExpectation("Collation Identifier"),
    function(n) {
        return {
          'type': 'identifier',
          'variant': 'collation',
          'name': n
        };
      },
    peg$otherExpectation("Savepoint Identifier"),
    function(n) {
        return {
          'type': 'identifier',
          'variant': 'savepoint',
          'name': n
        };
      },
    peg$otherExpectation("Index Identifier"),
    function(d, n) {
        return {
          'type': 'identifier',
          'variant': 'index',
          'name': foldStringWord([ d, n ])
        };
      },
    peg$otherExpectation("Trigger Identifier"),
    function(d, n) {
        return {
          'type': 'identifier',
          'variant': 'trigger',
          'name': foldStringWord([ d, n ])
        };
      },
    peg$otherExpectation("View Identifier"),
    function(d, n) {
        return {
          'type': 'identifier',
          'variant': 'view',
          'name': foldStringWord([ d, n ])
        };
      },
    peg$otherExpectation("Pragma Identifier"),
    function(d, n) {
        return {
          'type': 'identifier',
          'variant': 'pragma',
          'name': foldStringWord([ d, n ])
        };
      },
    peg$otherExpectation("Variable Identifier"),
    function(d, n) {
        return {
          'type': 'identifier',
          'variant': 'variable',
          'name': foldStringWord([ d, n ])
        };
      },
    peg$otherExpectation("CTE Identifier"),
    function(d) {
        return d;
      },
    function(n, a) {
        return Object.assign({
          'type': 'identifier',
          'variant': 'expression',
          'format': 'table',
          'name': n['name'],
          'columns': []
        }, a);
      },
    peg$otherExpectation("Table Constraint Identifier"),
    function(n) {
        return {
          'type': 'identifier',
          'variant': 'constraint',
          'format': 'table',
          'name': n
        };
      },
    peg$otherExpectation("Column Constraint Identifier"),
    function(n) {
        return {
          'type': 'identifier',
          'variant': 'constraint',
          'format': 'column',
          'name': n
        };
      },
    peg$otherExpectation("Datatype Name"),
    function(t) { return [t, 'text']; },
    function(t) { return [t, 'real']; },
    function(t) { return [t, 'numeric']; },
    function(t) { return [t, 'integer']; },
    function(t) { return [t, 'none']; },
    peg$otherExpectation("TEXT Datatype Name"),
    "n",
    peg$literalExpectation("N", true),
    "var",
    peg$literalExpectation("VAR", true),
    "char",
    peg$literalExpectation("CHAR", true),
    "tiny",
    peg$literalExpectation("TINY", true),
    "medium",
    peg$literalExpectation("MEDIUM", true),
    "long",
    peg$literalExpectation("LONG", true),
    "text",
    peg$literalExpectation("TEXT", true),
    "clob",
    peg$literalExpectation("CLOB", true),
    peg$otherExpectation("REAL Datatype Name"),
    "float",
    peg$literalExpectation("FLOAT", true),
    "real",
    peg$literalExpectation("REAL", true),
    peg$otherExpectation("DOUBLE Datatype Name"),
    "double",
    peg$literalExpectation("DOUBLE", true),
    "precision",
    peg$literalExpectation("PRECISION", true),
    function(d, p) { return foldStringWord([ d, p ]); },
    peg$otherExpectation("NUMERIC Datatype Name"),
    "numeric",
    peg$literalExpectation("NUMERIC", true),
    "decimal",
    peg$literalExpectation("DECIMAL", true),
    "boolean",
    peg$literalExpectation("BOOLEAN", true),
    "date",
    peg$literalExpectation("DATE", true),
    "stamp",
    peg$literalExpectation("STAMP", true),
    "string",
    peg$literalExpectation("STRING", true),
    peg$otherExpectation("INTEGER Datatype Name"),
    "int",
    peg$literalExpectation("INT", true),
    "2",
    peg$literalExpectation("2", false),
    "4",
    peg$literalExpectation("4", false),
    "8",
    peg$literalExpectation("8", false),
    "eger",
    peg$literalExpectation("EGER", true),
    "big",
    peg$literalExpectation("BIG", true),
    "small",
    peg$literalExpectation("SMALL", true),
    "floating",
    peg$literalExpectation("FLOATING", true),
    "point",
    peg$literalExpectation("POINT", true),
    function(f, p) {
        return foldStringWord([ f, p ]);
      },
    peg$otherExpectation("BLOB Datatype Name"),
    "blob",
    peg$literalExpectation("BLOB", true),
    /^[a-z0-9$_]/i,
    peg$classExpectation([["a", "z"], ["0", "9"], "$", "_"], false, true),
    "\\u",
    peg$literalExpectation("\\u", false),
    /^[a-f0-9]/i,
    peg$classExpectation([["a", "f"], ["0", "9"]], false, true),
    function(u, s) {
      return foldStringWord([ u, s ]).toLowerCase();
    },
    function(n) {
       return keyNode(n);
      },
    peg$anyExpectation(),
    function(n) {
        return textNode(n);
      },
    /^[ \t]/,
    peg$classExpectation([" ", "\t"], false, false),
    "\"",
    peg$literalExpectation("\"", false),
    "\"\"",
    peg$literalExpectation("\"\"", false),
    /^[^"]/,
    peg$classExpectation(["\""], true, false),
    function(n) { return unescape(n, '"'); },
    "'",
    peg$literalExpectation("'", false),
    function(n) { return unescape(n, "'"); },
    "`",
    peg$literalExpectation("`", false),
    "``",
    peg$literalExpectation("``", false),
    /^[^`]/,
    peg$classExpectation(["`"], true, false),
    function(n) { return unescape(n, '`'); },
    peg$otherExpectation("Open Bracket"),
    "[",
    peg$literalExpectation("[", false),
    peg$otherExpectation("Close Bracket"),
    "]",
    peg$literalExpectation("]", false),
    peg$otherExpectation("Open Parenthesis"),
    "(",
    peg$literalExpectation("(", false),
    peg$otherExpectation("Close Parenthesis"),
    ")",
    peg$literalExpectation(")", false),
    peg$otherExpectation("Comma"),
    ",",
    peg$literalExpectation(",", false),
    peg$otherExpectation("Period"),
    ".",
    peg$literalExpectation(".", false),
    peg$otherExpectation("Asterisk"),
    "*",
    peg$literalExpectation("*", false),
    peg$otherExpectation("Question Mark"),
    "?",
    peg$literalExpectation("?", false),
    peg$otherExpectation("Single Quote"),
    peg$otherExpectation("Double Quote"),
    peg$otherExpectation("Backtick"),
    peg$otherExpectation("Tilde"),
    "~",
    peg$literalExpectation("~", false),
    peg$otherExpectation("Plus"),
    "+",
    peg$literalExpectation("+", false),
    peg$otherExpectation("Minus"),
    "-",
    peg$literalExpectation("-", false),
    "=",
    peg$literalExpectation("=", false),
    peg$otherExpectation("Ampersand"),
    "&",
    peg$literalExpectation("&", false),
    peg$otherExpectation("Pipe"),
    "|",
    peg$literalExpectation("|", false),
    "%",
    peg$literalExpectation("%", false),
    "<",
    peg$literalExpectation("<", false),
    ">",
    peg$literalExpectation(">", false),
    peg$otherExpectation("Exclamation"),
    "!",
    peg$literalExpectation("!", false),
    peg$otherExpectation("Semicolon"),
    ";",
    peg$literalExpectation(";", false),
    peg$otherExpectation("Colon"),
    peg$otherExpectation("Forward Slash"),
    "/",
    peg$literalExpectation("/", false),
    peg$otherExpectation("Backslash"),
    "\\",
    peg$literalExpectation("\\", false),
    peg$otherExpectation("Operator characters"),
    /^[\-+*\/<>=~!@#%\^&|`]/,
    peg$classExpectation(["-", "+", "*", "/", "<", ">", "=", "~", "!", "@", "#", "%", "^", "&", "|", "`"], false, false),
    "abort",
    peg$literalExpectation("ABORT", true),
    "action",
    peg$literalExpectation("ACTION", true),
    "add",
    peg$literalExpectation("ADD", true),
    "after",
    peg$literalExpectation("AFTER", true),
    "alter",
    peg$literalExpectation("ALTER", true),
    "analyze",
    peg$literalExpectation("ANALYZE", true),
    "and",
    peg$literalExpectation("AND", true),
    "as",
    peg$literalExpectation("AS", true),
    "asc",
    peg$literalExpectation("ASC", true),
    "attach",
    peg$literalExpectation("ATTACH", true),
    "autoincrement",
    peg$literalExpectation("AUTOINCREMENT", true),
    "before",
    peg$literalExpectation("BEFORE", true),
    "begin",
    peg$literalExpectation("BEGIN", true),
    "between",
    peg$literalExpectation("BETWEEN", true),
    "by",
    peg$literalExpectation("BY", true),
    "cascade",
    peg$literalExpectation("CASCADE", true),
    "case",
    peg$literalExpectation("CASE", true),
    "cast",
    peg$literalExpectation("CAST", true),
    "check",
    peg$literalExpectation("CHECK", true),
    "collate",
    peg$literalExpectation("COLLATE", true),
    "column",
    peg$literalExpectation("COLUMN", true),
    "commit",
    peg$literalExpectation("COMMIT", true),
    "conflict",
    peg$literalExpectation("CONFLICT", true),
    "constraint",
    peg$literalExpectation("CONSTRAINT", true),
    "create",
    peg$literalExpectation("CREATE", true),
    "cross",
    peg$literalExpectation("CROSS", true),
    "current_date",
    peg$literalExpectation("CURRENT_DATE", true),
    "current_time",
    peg$literalExpectation("CURRENT_TIME", true),
    "current_timestamp",
    peg$literalExpectation("CURRENT_TIMESTAMP", true),
    "database",
    peg$literalExpectation("DATABASE", true),
    "default",
    peg$literalExpectation("DEFAULT", true),
    "deferrable",
    peg$literalExpectation("DEFERRABLE", true),
    "deferred",
    peg$literalExpectation("DEFERRED", true),
    "delete",
    peg$literalExpectation("DELETE", true),
    "desc",
    peg$literalExpectation("DESC", true),
    "detach",
    peg$literalExpectation("DETACH", true),
    "distinct",
    peg$literalExpectation("DISTINCT", true),
    "drop",
    peg$literalExpectation("DROP", true),
    "each",
    peg$literalExpectation("EACH", true),
    "else",
    peg$literalExpectation("ELSE", true),
    "end",
    peg$literalExpectation("END", true),
    "escape",
    peg$literalExpectation("ESCAPE", true),
    "except",
    peg$literalExpectation("EXCEPT", true),
    "exclusive",
    peg$literalExpectation("EXCLUSIVE", true),
    "exists",
    peg$literalExpectation("EXISTS", true),
    "explain",
    peg$literalExpectation("EXPLAIN", true),
    "fail",
    peg$literalExpectation("FAIL", true),
    "first",
    peg$literalExpectation("FIRST", true),
    "for",
    peg$literalExpectation("FOR", true),
    "foreign",
    peg$literalExpectation("FOREIGN", true),
    "from",
    peg$literalExpectation("FROM", true),
    "full",
    peg$literalExpectation("FULL", true),
    "glob",
    peg$literalExpectation("GLOB", true),
    "group",
    peg$literalExpectation("GROUP", true),
    "having",
    peg$literalExpectation("HAVING", true),
    "if",
    peg$literalExpectation("IF", true),
    "ignore",
    peg$literalExpectation("IGNORE", true),
    "ilike",
    peg$literalExpectation("ILIKE", true),
    "immediate",
    peg$literalExpectation("IMMEDIATE", true),
    "in",
    peg$literalExpectation("IN", true),
    "index",
    peg$literalExpectation("INDEX", true),
    "indexed",
    peg$literalExpectation("INDEXED", true),
    "initially",
    peg$literalExpectation("INITIALLY", true),
    "inner",
    peg$literalExpectation("INNER", true),
    "insert",
    peg$literalExpectation("INSERT", true),
    "instead",
    peg$literalExpectation("INSTEAD", true),
    "intersect",
    peg$literalExpectation("INTERSECT", true),
    "into",
    peg$literalExpectation("INTO", true),
    "is",
    peg$literalExpectation("IS", true),
    "isnull",
    peg$literalExpectation("ISNULL", true),
    "join",
    peg$literalExpectation("JOIN", true),
    "key",
    peg$literalExpectation("KEY", true),
    "last",
    peg$literalExpectation("LAST", true),
    "lateral",
    peg$literalExpectation("LATERAL", true),
    "left",
    peg$literalExpectation("LEFT", true),
    "like",
    peg$literalExpectation("LIKE", true),
    "limit",
    peg$literalExpectation("LIMIT", true),
    "locked",
    peg$literalExpectation("LOCKED", true),
    "match",
    peg$literalExpectation("MATCH", true),
    "natural",
    peg$literalExpectation("NATURAL", true),
    "no",
    peg$literalExpectation("NO", true),
    "not",
    peg$literalExpectation("NOT", true),
    "notnull",
    peg$literalExpectation("NOTNULL", true),
    "nowait",
    peg$literalExpectation("NOWAIT", true),
    "nulls",
    peg$literalExpectation("NULLS", true),
    "of",
    peg$literalExpectation("OF", true),
    "offset",
    peg$literalExpectation("OFFSET", true),
    "on",
    peg$literalExpectation("ON", true),
    "only",
    peg$literalExpectation("ONLY", true),
    "or",
    peg$literalExpectation("OR", true),
    "order",
    peg$literalExpectation("ORDER", true),
    "outer",
    peg$literalExpectation("OUTER", true),
    "over",
    peg$literalExpectation("OVER", true),
    "partition",
    peg$literalExpectation("PARTITION", true),
    "plan",
    peg$literalExpectation("PLAN", true),
    "pragma",
    peg$literalExpectation("PRAGMA", true),
    "primary",
    peg$literalExpectation("PRIMARY", true),
    "query",
    peg$literalExpectation("QUERY", true),
    "raise",
    peg$literalExpectation("RAISE", true),
    "read",
    peg$literalExpectation("READ", true),
    "recursive",
    peg$literalExpectation("RECURSIVE", true),
    "references",
    peg$literalExpectation("REFERENCES", true),
    "regexp",
    peg$literalExpectation("REGEXP", true),
    "reindex",
    peg$literalExpectation("REINDEX", true),
    "release",
    peg$literalExpectation("RELEASE", true),
    "rename",
    peg$literalExpectation("RENAME", true),
    "replace",
    peg$literalExpectation("REPLACE", true),
    "restrict",
    peg$literalExpectation("RESTRICT", true),
    "returning",
    peg$literalExpectation("RETURNING", true),
    "right",
    peg$literalExpectation("RIGHT", true),
    "rollback",
    peg$literalExpectation("ROLLBACK", true),
    "row",
    peg$literalExpectation("ROW", true),
    "rowid",
    peg$literalExpectation("ROWID", true),
    "savepoint",
    peg$literalExpectation("SAVEPOINT", true),
    "select",
    peg$literalExpectation("SELECT", true),
    "set",
    peg$literalExpectation("SET", true),
    "share",
    peg$literalExpectation("SHARE", true),
    "show",
    peg$literalExpectation("SHOW", true),
    "skip",
    peg$literalExpectation("SKIP", true),
    "table",
    peg$literalExpectation("TABLE", true),
    "temp",
    peg$literalExpectation("TEMP", true),
    "temporary",
    peg$literalExpectation("TEMPORARY", true),
    "then",
    peg$literalExpectation("THEN", true),
    "to",
    peg$literalExpectation("TO", true),
    "trigger",
    peg$literalExpectation("TRIGGER", true),
    "union",
    peg$literalExpectation("UNION", true),
    "unique",
    peg$literalExpectation("UNIQUE", true),
    "update",
    peg$literalExpectation("UPDATE", true),
    "using",
    peg$literalExpectation("USING", true),
    "vacuum",
    peg$literalExpectation("VACUUM", true),
    "values",
    peg$literalExpectation("VALUES", true),
    "view",
    peg$literalExpectation("VIEW", true),
    "virtual",
    peg$literalExpectation("VIRTUAL", true),
    "when",
    peg$literalExpectation("WHEN", true),
    "where",
    peg$literalExpectation("WHERE", true),
    "window",
    peg$literalExpectation("WINDOW", true),
    "with",
    peg$literalExpectation("WITH", true),
    "without",
    peg$literalExpectation("WITHOUT", true),
    function(r) { return keyNode(r); },
    function() { return null; },
    peg$otherExpectation("Line Comment"),
    "--",
    peg$literalExpectation("--", false),
    /^[\n\v\f\r]/,
    peg$classExpectation(["\n", "\v", "\f", "\r"], false, false),
    peg$otherExpectation("Block Comment"),
    "/*",
    peg$literalExpectation("/*", false),
    "*/",
    peg$literalExpectation("*/", false),
    /^[\n\v\f\r\t ]/,
    peg$classExpectation(["\n", "\v", "\f", "\r", "\t", " "], false, false),
    peg$otherExpectation("Whitespace"),
    "__TODO__",
    peg$literalExpectation("__TODO__", false)
  ];

  var peg$bytecode = [
    peg$decode("%;\u027C/H#;#/?$;\".\" &\"/1$;#/($8$: $!!)($'#(#'#(\"'#&'#"),
    peg$decode("%;\u027C/C#;#/:$;\x80/1$;#/($8$: $!!)($'#(#'#(\"'#&'#"),
    peg$decode("%;\x80/B#;\u027C/9$$;%0#*;%&/)$8#:!#\"\" )(#'#(\"'#&'#"),
    peg$decode("$;\u01DF0#*;\u01DF&"),
    peg$decode("$;\u01DF/&#0#*;\u01DF&&&#"),
    peg$decode("%;$/:#;\x80/1$;\u027C/($8#:\"#!!)(#'#(\"'#&'#"),
    peg$decode("<%;'.# &;(/@#;\u027C/7$;*.\" &\"/)$8#:$#\"\" )(#'#(\"'#&'#=.\" 7#"),
    peg$decode("%;\u01B7/' 8!:%!! )"),
    peg$decode("<%;\u01C1/9#$;)0#*;)&/)$8\":'\"\"! )(\"'#&'#=.\" 7&"),
    peg$decode("%4(\"\"5!7)/1#;\u01C3/($8\":*\"! )(\"'#&'#"),
    peg$decode("<%;\u01CC/R#;6/I$;\u027C/@$;+.\" &\"/2$;\u01CD/)$8%:,%\"#!)(%'#($'#(#'#(\"'#&'#=.\" 7+"),
    peg$decode("%;\u01CE/C#;\u027C/:$;6/1$;\u027C/($8$:-$!!)($'#(#'#(\"'#&'#"),
    peg$decode(";6.A &;7.; &;2.5 &;-./ &;..) &;/.# &;3"),
    peg$decode("<%;\u0239/1#;\u027C/($8\":/\"!!)(\"'#&'#=.\" 7."),
    peg$decode("<%;\u01FF.) &;\u0201.# &;\u0200/1#;\u027C/($8\":1\"!!)(\"'#&'#=.\" 70"),
    peg$decode("<%;5.\" &\"/2#;0/)$8\":3\"\"! )(\"'#&'#=.\" 72"),
    peg$decode("<%;\u01D2/A#$;10#*;1&/1$;\u01D2/($8#:5#!!)(#'#(\"'#&'#=.\" 74"),
    peg$decode("26\"\"6677.) &48\"\"5!79"),
    peg$decode("<%4;\"\"5!7</1#;0/($8\":=\"! )(\"'#&'#=.\" 7:"),
    peg$decode("<%;&/8#;/.# &;@/)$8\":?\"\"! )(\"'#&'#=.\" 7>"),
    peg$decode("%;\u01C3.# &;\u01C7/' 8!:@!! )"),
    peg$decode("<%;\u01D6.# &;\u01D7/' 8!:\"!! )=.\" 7A"),
    peg$decode("%;5.\" &\"/2#;7/)$8\":B\"\"! )(\"'#&'#"),
    peg$decode(";=.# &;8"),
    peg$decode("%;9/7#;<.\" &\"/)$8\":C\"\"! )(\"'#&'#"),
    peg$decode("<;:.# &;;=.\" 7D"),
    peg$decode("%$;?/&#0#*;?&&&#/7#;;.\" &\"/)$8\":E\"\"! )(\"'#&'#"),
    peg$decode("%;\u01CF/9#$;?0#*;?&/)$8\":F\"\"! )(\"'#&'#"),
    peg$decode("<%3H\"\"5!7I/T#4J\"\"5!7K.\" &\"/@$$;?/&#0#*;?&&&#/*$8#:L##\"! )(#'#(\"'#&'#=.\" 7G"),
    peg$decode("<%3N\"\"5\"7O/?#$;>/&#0#*;>&&&#/)$8\":P\"\"! )(\"'#&'#=.\" 7M"),
    peg$decode("4Q\"\"5!7R"),
    peg$decode("4S\"\"5!7T"),
    peg$decode("<%;A.) &;C.# &;D/' 8!:V!! )=.\" 7U"),
    peg$decode("<%;\u01D1/@#;B.\" &\"/2$;\u027C/)$8#:X#\"\"!)(#'#(\"'#&'#=.\" 7W"),
    peg$decode("%4Y\"\"5!7Z/9#$;?0#*;?&/)$8\":[\"\"! )(\"'#&'#"),
    peg$decode("<%4]\"\"5!7^/H#$;\u01BF/&#0#*;\u01BF&&&#/2$;\u027C/)$8#:_#\"\"!)(#'#(\"'#&'#=.\" 7\\"),
    peg$decode("<%2a\"\"6a7b/o#$;\u01BF.) &2c\"\"6c7d/2#0/*;\u01BF.) &2c\"\"6c7d&&&#/A$;\u027C/8$;E.\" &\"/*$8$:e$##\" )($'#(#'#(\"'#&'#=.\" 7`"),
    peg$decode("%;\u01C7/1#;\u027C/($8\":f\"!!)(\"'#&'#"),
    peg$decode("<%;G.\" &\"/;#;\u027C/2$;\x9C/)$8#:h#\"\" )(#'#(\"'#&'#=.\" 7g"),
    peg$decode("<%;n.\" &\"/;#;\u0211/2$;\u027C/)$8#:j#\"\"!)(#'#(\"'#&'#=.\" 7i"),
    peg$decode("<%;\u0248/_#;\u027C/V$;\u01CC/M$;\u027C/D$;I/;$;\u027C/2$;\u01CD/)$8':l'\"&\")(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7k"),
    peg$decode("<%;J.# &;K/' 8!:n!! )=.\" 7m"),
    peg$decode("<%;\u021D/' 8!:p!! )=.\" 7o"),
    peg$decode("%;\u0254.) &;\u01E4.# &;\u0213/M#;\u027C/D$;\u01CE/;$;\u027C/2$;\x7F/)$8%:q%\"$ )(%'#($'#(#'#(\"'#&'#"),
    peg$decode(";@./ &;w.) &;,.# &;\u01A0"),
    peg$decode("%;\u01CC/L#;\u027C/C$;s/:$;\u027C/1$;\u01CD/($8%:r%!\")(%'#($'#(#'#(\"'#&'#"),
    peg$decode(";M.; &;F.5 &;a./ &;c.) &;H.# &;L"),
    peg$decode("%;N/;#;\u027C/2$;S/)$8#:s#\"\" )(#'#(\"'#&'#.# &;N"),
    peg$decode("<%;O/S#;\u027C/J$2u\"\"6u7v/;$;\u027C/2$;&/)$8%:w%\"$ )(%'#($'#(#'#(\"'#&'#.# &;O=.\" 7t"),
    peg$decode("%;R/A#;\u027C/8$;P.# &;s/)$8#:x#\"\" )(#'#(\"'#&'#.# &;P"),
    peg$decode(";\u01D5.U &;\u01D7.O &;\u01D6.I &%%;n/8#%<;\u0211=.##&&!&'#/#$+\")(\"'#&'#/\"!&,)"),
    peg$decode("<%;\u014F/' 8!:z!! )=.\" 7y"),
    peg$decode("%;Q/\x83#$%;\u027C/>#;\u0188/5$;\u027C/,$;Q/#$+$)($'#(#'#(\"'#&'#0H*%;\u027C/>#;\u0188/5$;\u027C/,$;Q/#$+$)($'#(#'#(\"'#&'#&/)$8\":{\"\"! )(\"'#&'#"),
    peg$decode("%;T/\x83#$%;\u027C/>#;V/5$;\u027C/,$;T/#$+$)($'#(#'#(\"'#&'#0H*%;\u027C/>#;V/5$;\u027C/,$;T/#$+$)($'#(#'#(\"'#&'#&/)$8\":{\"\"! )(\"'#&'#"),
    peg$decode(";\u018B.) &;\u018C.# &;\u018D"),
    peg$decode("%;U/\x83#$%;\u027C/>#;X/5$;\u027C/,$;U/#$+$)($'#(#'#(\"'#&'#0H*%;\u027C/>#;X/5$;\u027C/,$;U/#$+$)($'#(#'#(\"'#&'#&/)$8\":{\"\"! )(\"'#&'#"),
    peg$decode(";\u0189.# &;\u018A"),
    peg$decode("%;W/\x83#$%;\u027C/>#;Z/5$;\u027C/,$;W/#$+$)($'#(#'#(\"'#&'#0H*%;\u027C/>#;Z/5$;\u027C/,$;W/#$+$)($'#(#'#(\"'#&'#&/)$8\":{\"\"! )(\"'#&'#"),
    peg$decode(";\u018E.[ &;\u018F.U &;\u0190.O &;\u0199.I &%%;\u0191/8#%<;\u0191=.##&&!&'#/#$+\")(\"'#&'#/\"!&,)"),
    peg$decode("%;Y/\x83#$%;\u027C/>#;\\/5$;\u027C/,$;Y/#$+$)($'#(#'#(\"'#&'#0H*%;\u027C/>#;\\/5$;\u027C/,$;Y/#$+$)($'#(#'#(\"'#&'#&/)$8\":{\"\"! )(\"'#&'#"),
    peg$decode(";\u0194.{ &;\u0195.u &%%;\u0192/8#%<;Z=.##&&!&'#/#$+\")(\"'#&'#/\"!&,).I &%%;\u0193/8#%<;Z=.##&&!&'#/#$+\")(\"'#&'#/\"!&,)"),
    peg$decode("%;[/9#$;^0#*;^&/)$8\":{\"\"! )(\"'#&'#"),
    peg$decode("%;\u027C/1#;_/($8\":|\"! )(\"'#&'#.H &%;\u027C/>#;`/5$;\u027C/,$;[/#$+$)($'#(#'#(\"'#&'#"),
    peg$decode("%3}\"\"5$7~/?#;\u027C/6$3\x7F\"\"5$7\x80/'$8#:\x81# )(#'#(\"'#&'#.? &%;\u022A/& 8!:\x82! ).. &%;\u0237/& 8!:\x81! )"),
    peg$decode(";\u019A./ &;\u0197.) &;\u0198.# &;\u0196"),
    peg$decode("<%;\u01F6/i#;\u027C/`$;\u01CC/W$;s/N$;\u027C/E$;b/<$;\u027C/3$;\u01CD/*$8(:\x84(#'$\")(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\x83"),
    peg$decode("<%;\u01EC/:#;\u027C/1$;&/($8#:\x86#! )(#'#(\"'#&'#=.\" 7\x85"),
    peg$decode("<%;\u01F5/\x93#;\u027C/\x8A$;d.\" &\"/|$;\u027C/s$$;e/&#0#*;e&&&#/]$;\u027C/T$;f.\" &\"/F$;\u027C/=$;\u020D/4$;\u027C/+$8*:\x88*$)'%#)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\x87"),
    peg$decode("%%<;\u026C=.##&&!&'#/1#;s/($8\":\x89\"! )(\"'#&'#"),
    peg$decode("<%;\u026C/i#;\u027C/`$;s/W$;\u027C/N$;\u0260/E$;\u027C/<$;s/3$;\u027C/*$8(:\x8B(#'%!)(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\x8A"),
    peg$decode("<%;\u020C/D#;\u027C/;$;s/2$;\u027C/)$8$:\x8D$\"#!)($'#(#'#(\"'#&'#=.\" 7\x8C"),
    peg$decode("%;]/;#;\u027C/2$;h/)$8#:\x8E#\"\" )(#'#(\"'#&'#.# &;]"),
    peg$decode(";o./ &;i.) &;l.# &;j"),
    peg$decode("<%;\u0229/n#;\u027C/e$;n.\" &\"/W$;\u0209/N$;\u027C/E$;\u0217/<$;\u027C/3$;g/*$8(:\x90(#%$ )(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\x8F"),
    peg$decode("<%;n.\" &\"/u#;\u0230.5 &;\u021E./ &;\u0219.) &;\u024C.# &;\u0233/T$;\u027C/K$;g/B$;\u027C/9$;k.\" &\"/+$8&:\x92&$%$\" )(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\x91"),
    peg$decode("<%;\u020E/D#;\u027C/;$;g/2$;\u027C/)$8$:\x94$\"#!)($'#(#'#(\"'#&'#=.\" 7\x93"),
    peg$decode("<%;n.\" &\"/E#;\u01F2/<$;\u027C/3$;m/*$8$:\x96$##\" )($'#(#'#(\"'#&'#=.\" 7\x95"),
    peg$decode("%;g/W#%;\u027C/>#;\u01EB/5$;\u027C/,$;g/#$+$)($'#(#'#(\"'#&'#/)$8\":\x97\"\"! )(\"'#&'#"),
    peg$decode("%;\u0236/1#;\u027C/($8\":\x98\"!!)(\"'#&'#"),
    peg$decode("<%;n.\" &\"/E#;\u0220/<$;\u027C/3$;p/*$8$:\x9A$##\" )($'#(#'#(\"'#&'#=.\" 7\x99"),
    peg$decode(";q.# &;\u019E"),
    peg$decode("%;\u01CC/I#;\x9D.# &;t/:$;\u027C/1$;\u01CD/($8$:\x9B$!\")($'#(#'#(\"'#&'#"),
    peg$decode("%;g/\x83#$%;\u027C/>#;\u01EB/5$;\u027C/,$;g/#$+$)($'#(#'#(\"'#&'#0H*%;\u027C/>#;\u01EB/5$;\u027C/,$;g/#$+$)($'#(#'#(\"'#&'#&/)$8\":{\"\"! )(\"'#&'#"),
    peg$decode("%;r/\x83#$%;\u027C/>#;\u023F/5$;\u027C/,$;r/#$+$)($'#(#'#(\"'#&'#0H*%;\u027C/>#;\u023F/5$;\u027C/,$;r/#$+$)($'#(#'#(\"'#&'#&/)$8\":{\"\"! )(\"'#&'#"),
    peg$decode("<%;u.\" &\"/1#;\u027C/($8\":\x9D\"!!)(\"'#&'#=.\" 7\x9C"),
    peg$decode("%;s/B#;\u027C/9$$;v0#*;v&/)$8#:\x9E#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u01CE/:#;s/1$;\u027C/($8#:\x9B#!!)(#'#(\"'#&'#"),
    peg$decode("<%;\u019D/s#;\u027C/j$;\u01CC/a$;x.\" &\"/S$;\u027C/J$;\u01CD/A$;\u027C/8$;z.\" &\"/*$8(:\xA0(#'$ )(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\x9F"),
    peg$decode("<%;\xF8/' 8!:\xA2!! ).V &%;y.\" &\"/G#;t/>$9:\xA3 \"! -\"\"&!&#/)$8#:\xA4#\"\"!)(#'#(\"'#&'#=.\" 7\xA1"),
    peg$decode("%;\u0209.# &;\u01E8/1#;\u027C/($8\":\xA5\"!!)(\"'#&'#"),
    peg$decode("<%;\u0242/@#;\u027C/7$;|.# &;{/($8#:\xA7#! )(#'#(\"'#&'#=.\" 7\xA6"),
    peg$decode("<%;\u019B/' 8!:\xA9!! )=.\" 7\xA8"),
    peg$decode("<%;\u01CC/\x81#;\u027C/x$;}.\" &\"/j$;\u027C/a$;~.\" &\"/S$;\u027C/J$;\xC0.\" &\"/<$;\u027C/3$;\u01CD/*$8):\xAB)#&$\")()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\xAA"),
    peg$decode("%;{/P#%<%;\u027C/,#;\u01F3/#$+\")(\"'#&'#=.##&&!&'#/($8\":\xAC\"!!)(\"'#&'#"),
    peg$decode("<%;\u0243/L#;\u027C/C$;\u01F3/:$;\u027C/1$;t/($8%:\xAE%! )(%'#($'#(#'#(\"'#&'#=.\" 7\xAD"),
    peg$decode("<%;//' 8!:\xB0!! )=.\" 7\xAF"),
    peg$decode("<%;\x81.\" &\"/;#;\x83/2$;\u027C/)$8#:\xB2#\"\"!)(#'#(\"'#&'#=.\" 7\xB1"),
    peg$decode("<%;\u0212/@#;\u027C/7$;\x82.\" &\"/)$8#:\xB4#\"\" )(#'#(\"'#&'#=.\" 7\xB3"),
    peg$decode("<%;\u0247/D#;\u027C/;$;\u0244/2$;\u027C/)$8$:\xB6$\"#!)($'#(#'#(\"'#&'#=.\" 7\xB5"),
    peg$decode(";\x94.Y &;\u011D.S &;\u0184.M &;\x85.G &;\x84.A &;\x8E.; &;\x88.5 &;\x8C./ &;\x8D.) &;\x9E.# &;\xA0"),
    peg$decode("<%;\u01FA.# &;\u020D/@#;\u027C/7$;\x86.\" &\"/)$8#:\xB8#\"\" )(#'#(\"'#&'#=.\" 7\xB7"),
    peg$decode("<%;\u01F1/^#;\u027C/U$;\x87.\" &\"/G$;\x86.\" &\"/9$;\x8A.\" &\"/+$8%:\xBA%$$\"! )(%'#($'#(#'#(\"'#&'#=.\" 7\xB9"),
    peg$decode("%;\u0262/1#;\u027C/($8\":\xBB\"!!)(\"'#&'#"),
    peg$decode("%;\u0205.) &;\u021F.# &;\u0210/1#;\u027C/($8\":\xBC\"!!)(\"'#&'#"),
    peg$decode("<%;\u0254/N#;\u027C/E$;\x86.\" &\"/7$;\x89.\" &\"/)$8$:\xBE$\"# )($'#(#'#(\"'#&'#=.\" 7\xBD"),
    peg$decode("<%%;\u0261/,#;\u027C/#$+\")(\"'#&'#.\" &\"/?#;\x8B.\" &\"/1$;\x8A/($8#:r#! )(#'#(\"'#&'#=.\" 7\xBF"),
    peg$decode("%;\u01AD/1#;\u027C/($8\":\xC0\"!!)(\"'#&'#"),
    peg$decode("%;\u0257/1#;\u027C/($8\":\xC1\"!!)(\"'#&'#"),
    peg$decode("<%;\x8B/2#;\x8A/)$8\":\xC3\"\"! )(\"'#&'#=.\" 7\xC2"),
    peg$decode("<%;\u024E/J#;\u027C/A$;\x8B.\" &\"/3$;\x8A/*$8$:\xC5$##! )($'#(#'#(\"'#&'#=.\" 7\xC4"),
    peg$decode("<%;\x8F/N#;\u019E/E$;\u027C/<$;\x90/3$;\u027C/*$8%:\xC7%#$#!)(%'#($'#(#'#(\"'#&'#=.\" 7\xC6"),
    peg$decode("<%;\u01E9/D#;\u027C/;$;\u025D/2$;\u027C/)$8$:\xC9$\"#!)($'#(#'#(\"'#&'#=.\" 7\xC8"),
    peg$decode(";\x91.# &;\x92"),
    peg$decode("<%;\u024F/M#;\u027C/D$;\u0261/;$;\u027C/2$;\u019E/)$8%:\xCB%\"$ )(%'#($'#(#'#(\"'#&'#=.\" 7\xCA"),
    peg$decode("<%;\u01E6/I#;\u027C/@$;\x93.\" &\"/2$;\u012E/)$8$:\xCD$\"# )($'#(#'#(\"'#&'#=.\" 7\xCC"),
    peg$decode("%;\u01F9/1#;\u027C/($8\":\xC1\"!!)(\"'#&'#"),
    peg$decode("%;\x95/2#;\xB1/)$8\":\xCE\"\"! )(\"'#&'#"),
    peg$decode("<%;\x96.\" &\"/1#;\u027C/($8\":*\"!!)(\"'#&'#=.\" 7\xCF"),
    peg$decode("%;\u026F/J#;\u027C/A$;\x97.\" &\"/3$;\x98/*$8$:\xD0$##! )($'#(#'#(\"'#&'#"),
    peg$decode("%;\u024A/1#;\u027C/($8\":\xC1\"!!)(\"'#&'#"),
    peg$decode("%;\x9A/B#;\u027C/9$$;\x990#*;\x99&/)$8#:\xD1#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u01CE/:#;\x9A/1$;\u027C/($8#:\x9B#!!)(#'#(\"'#&'#"),
    peg$decode("<%;\u01B3/2#;\x9B/)$8\":\xD3\"\"! )(\"'#&'#=.\" 7\xD2"),
    peg$decode("%;\u01EC/:#;\u027C/1$;\x9C/($8#:\xD4#! )(#'#(\"'#&'#"),
    peg$decode("%;\u01CC/C#;\x9D/:$;\u027C/1$;\u01CD/($8$: $!\")($'#(#'#(\"'#&'#"),
    peg$decode("%;\x95/2#;\xB2/)$8\":\xD5\"\"! )(\"'#&'#"),
    peg$decode("%;\u025B/:#;\u027C/1$;\x9F/($8#:\xD6#! )(#'#(\"'#&'#"),
    peg$decode("%3\xD7\"\"5$7\xD8/?#;\u027C/6$3\xD9\"\"5$7\xDA/'$8#:\xDB# )(#'#(\"'#&'#.\xB6 &%3\xDC\"\"5+7\xDD/W#;\u027C/N$3\xDE\"\"5)7\xDF/?$;\u027C/6$3\xE0\"\"5%7\xE1/'$8%:\xE2% )(%'#($'#(#'#(\"'#&'#.l &%3\xE3\"\"5'7\xE4/?#;\u027C/6$3\xE5\"\"5-7\xE6/'$8#:\xE7# )(#'#(\"'#&'#.: &%3\xE8\"\"5#7\xE9/& 8!:\xEA! ).# &;\u01B2"),
    peg$decode(";\xA1.; &;\xA3.5 &;\xA4./ &;\xA6.) &;\xA8.# &;\xAA"),
    peg$decode("<%;\u01EE/\x8B#;\u027C/\x82$%;\u0202/,#;\u027C/#$+\")(\"'#&'#.\" &\"/a$;s/X$;\u027C/O$;\u01EC/F$;\u027C/=$;\xA2/4$;\u027C/+$8):\xEC)$(&%!)()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\xEB"),
    peg$decode(";\u019C.) &;-.# &;@"),
    peg$decode("<%;\u0208/f#;\u027C/]$%;\u0202/,#;\u027C/#$+\")(\"'#&'#.\" &\"/<$;\xA2/3$;\u027C/*$8%:\xEE%#$\"!)(%'#($'#(#'#(\"'#&'#=.\" 7\xED"),
    peg$decode("<%;\u0268/@#;\u027C/7$;\xA5.\" &\"/)$8#:\xF0#\"\" )(#'#(\"'#&'#=.\" 7\xEF"),
    peg$decode("%;\u019C/1#;\u027C/($8\":\xF1\"!!)(\"'#&'#"),
    peg$decode("<%;\u01EA/@#;\u027C/7$;\xA7.\" &\"/)$8#:\xF3#\"\" )(#'#(\"'#&'#=.\" 7\xF2"),
    peg$decode("%;\u019E.) &;\u01AE.# &;\u019C/1#;\u027C/($8\":\xF4\"!!)(\"'#&'#"),
    peg$decode("<%;\u024D/I#;\u027C/@$;\xA9.\" &\"/2$;\u027C/)$8$:\xF3$\"#!)($'#(#'#(\"'#&'#=.\" 7\xF5"),
    peg$decode("%;\u019E.) &;\u01AE.# &;\u01AC/1#;\u027C/($8\":\xF6\"!!)(\"'#&'#"),
    peg$decode("<%;\u0245/S#;\u027C/J$;\u01B1/A$;\u027C/8$;\xAB.\" &\"/*$8%:\xF8%#$\" )(%'#($'#(#'#(\"'#&'#=.\" 7\xF7"),
    peg$decode("%;\u01CC/C#;\xAC/:$;\u027C/1$;\u01CD/($8$:\xF9$!\")($'#(#'#(\"'#&'#.D &%;\u01D8/:#;\xAC/1$;\u027C/($8#:\xF9#!!)(#'#(\"'#&'#"),
    peg$decode(";\xAE.) &;\xAD.# &;\xB0"),
    peg$decode(";6.) &;/.# &;4"),
    peg$decode("%;\xAF/<#9:\xFA ! -\"\"&!&#/($8\":\xFB\"!!)(\"'#&'#"),
    peg$decode("%$;\u01BF/&#0#*;\u01BF&&&#/' 8!:\xFC!! )"),
    peg$decode("%;\xAF/' 8!:\xFD!! )"),
    peg$decode(";\xB2./ &;\xFA.) &;\u0113.# &;\u011B"),
    peg$decode("<%;\xC5/k#;\u027C/b$;\xC0.\" &\"/T$;\u027C/K$;\xC1/B$;\u027C/9$;\xB3.\" &\"/+$8':\xFF'$&$\" )(''#(&'#(%'#($'#(#'#(\"'#&'#.z &%;\xC5/p#;\u027C/g$;\xC0.\" &\"/Y$;\u027C/P$;\xB3.\" &\"/B$;\u027C/9$;\xC1.\" &\"/+$8':\u0100'$&$\" )(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\xFE"),
    peg$decode("<;\xB4.^ &%;\u0215/T#;\u027C/K$;\u0249/B$;\u027C/9$;\u023E/0$;\u027C/'$8&:\u0102& )(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u0101"),
    peg$decode("%;\xB6/B#;\u027C/9$$;\xB50#*;\xB5&/)$8#:\u0103#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\xB6/1#;\u027C/($8\":\u0104\"!!)(\"'#&'#"),
    peg$decode("%;\u0215/j#;\u027C/a$;\xB7/X$;\u027C/O$;\xB8.\" &\"/A$;\u027C/8$;\xBB.\" &\"/*$8':\u0105'#$\" )(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode(";\u0266.y &%;\u0235/G#;\u027C/>$;\u022C/5$;\u027C/,$;\u0266/#$+%)(%'#($'#(#'#(\"'#&'#.E &;\u025A.? &%;\u022C/5#;\u027C/,$;\u025A/#$+#)(#'#(\"'#&'#"),
    peg$decode("%;\u023B/:#;\u027C/1$;\xB9/($8#:\u0106#! )(#'#(\"'#&'#"),
    peg$decode("%;\u019E/B#;\u027C/9$$;\xBA0#*;\xBA&/)$8#:\u0107#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u01CE/:#;\u027C/1$;\u019E/($8#:\u0104#! )(#'#(\"'#&'#"),
    peg$decode("%;\u0238.? &%;\u025C/5#;\u027C/,$;\u0232/#$+#)(#'#(\"'#&'#/' 8!:\u0108!! )"),
    peg$decode("<%;\u026E/C#;\u027C/:$;\xBD/1$;\u027C/($8$:\u010A$!!)($'#(#'#(\"'#&'#=.\" 7\u0109"),
    peg$decode("%;\xBF/B#;\u027C/9$$;\xBE0#*;\xBE&/)$8#:\xD1#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u01CE/:#;\xBF/1$;\u027C/($8#:-#!!)(#'#(\"'#&'#"),
    peg$decode("%;{/M#;\u027C/D$;\u01EC/;$;\u027C/2$;|/)$8%:\u010B%\"$ )(%'#($'#(#'#(\"'#&'#"),
    peg$decode("<%;\u0240/L#;\u027C/C$;\u01F3/:$;\u027C/1$;\xF4/($8%:\u010D%! )(%'#($'#(#'#(\"'#&'#=.\" 7\u010C"),
    peg$decode("<%;\u0231/S#;\u027C/J$;s/A$;\u027C/8$;\xC2.\" &\"/*$8%:\u010F%#$\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u010E"),
    peg$decode("<%;\xC3/2#;s/)$8\":\u0111\"\"! )(\"'#&'#=.\" 7\u0110"),
    peg$decode(";\xC4.# &;\u01CE"),
    peg$decode("%;\u023C/1#;\u027C/($8\":\xC1\"!!)(\"'#&'#"),
    peg$decode("%;\xC7/B#;\u027C/9$$;\xC60#*;\xC6&/)$8#:\u0112#\"\" )(#'#(\"'#&'#"),
    peg$decode("<%;\u0110/D#;\u027C/;$;\xC7/2$;\u027C/)$8$:\u0114$\"#!)($'#(#'#(\"'#&'#=.\" 7\u0113"),
    peg$decode(";\xC8.# &;\xF3"),
    peg$decode("%;\xC9/m#;\xCF.\" &\"/_$;\xD0.\" &\"/Q$;\xD1.\" &\"/C$;\u027C/:$;\xBC.\" &\"/,$8&:\u0115&%%$#\" )(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("<%;\u0258/R#;\u027C/I$;\xCA.\" &\"/;$;\u027C/2$;\xCD/)$8%:\u0117%\"\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u0116"),
    peg$decode("<;\xCB.# &;\xCC=.\" 7\u0118"),
    peg$decode("%;\u0209/1#;\u027C/($8\":\u0119\"!!)(\"'#&'#"),
    peg$decode("%;\u01E8/1#;\u027C/($8\":\u011A\"!!)(\"'#&'#"),
    peg$decode("%;\xD3/B#;\u027C/9$$;\xCE0#*;\xCE&/)$8#:\xD1#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u01CE/:#;\xD3/1$;\u027C/($8#:-#!!)(#'#(\"'#&'#"),
    peg$decode("<%;\u0217/D#;\u027C/;$;\xD7/2$;\u027C/)$8$:\u011C$\"#!)($'#(#'#(\"'#&'#=.\" 7\u011B"),
    peg$decode("<%;\u026D/D#;\u027C/;$;s/2$;\u027C/)$8$:\u011E$\"#!)($'#(#'#(\"'#&'#=.\" 7\u011D"),
    peg$decode("<%;\u021A/e#;\u027C/\\$;\u01F3/S$;\u027C/J$;t/A$;\u027C/8$;\xD2.\" &\"/*$8':\u0120'#&\" )(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u011F"),
    peg$decode("<%;\u021B/D#;\u027C/;$;s/2$;\u027C/)$8$:\u0122$\"#!)($'#(#'#(\"'#&'#=.\" 7\u0121"),
    peg$decode(";\xD4.# &;\xD6"),
    peg$decode("%;\xD5.\" &\"/2#;\xF8/)$8\":\u0123\"\"! )(\"'#&'#"),
    peg$decode("%;\u01C1/2#;\u01CF/)$8\":\u0124\"\"! )(\"'#&'#"),
    peg$decode("%;s/@#;\u027C/7$;\xE9.\" &\"/)$8#:\u0125#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\xDB/B#;\u027C/9$$;\xD80#*;\xD8&/)$8#:\u0126#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\xD9.# &;\xDA/7#;\xF0.\" &\"/)$8\":\u0127\"\"! )(\"'#&'#"),
    peg$decode("<%;\u01CE/:#;\xDB/1$;\u027C/($8#:\u0129#!!)(#'#(\"'#&'#=.\" 7\u0128"),
    peg$decode("<%;\xEA/D#;\u027C/;$;\xDB/2$;\u027C/)$8$:\u012B$\"#!)($'#(#'#(\"'#&'#=.\" 7\u012A"),
    peg$decode("%;\xE1.\" &\"/S#;\u027C/J$;\xE7.5 &;@./ &;\xDC.) &;\xE2.# &;\xE8/)$8#:\u012C#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u019D/S#;\u027C/J$;\u010E/A$;\u027C/8$;\xDD.\" &\"/*$8%:\u012D%#$\" )(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;\u01EC.\" &\"/h#;\u027C/_$;\u01C1/V$;\u027C/M$;\u01CC/D$;\xDE/;$;\u027C/2$;\u01CD/)$8(:\u012E(\"%\")(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.n &%;\u01EC/^#;\u027C/U$;\u01CC/L$;\u027C/C$;\xDE/:$;\u027C/1$;\u01CD/($8':\u012F'!\")(''#(&'#(%'#($'#(#'#(\"'#&'#.# &;\xE9"),
    peg$decode("%;\xDF/B#;\u027C/9$$;\xE00#*;\xE0&/)$8#:\u0130#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u012F/S#;\u027C/J$;&/A$;\u027C/8$;\u014F.\" &\"/*$8%:\u0131%#$\" )(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;\u01CE/C#;\u027C/:$;\xDF/1$;\u027C/($8$:\xBB$!!)($'#(#'#(\"'#&'#"),
    peg$decode("%;\u022E/& 8!:\u0132! )"),
    peg$decode("<%;\xE3/@#;\u027C/7$;\xE4.\" &\"/)$8#:\u0134#\"\" )(#'#(\"'#&'#=.\" 7\u0133"),
    peg$decode("<%;\u019E/@#;\u027C/7$;\xE9.\" &\"/)$8#:\u0136#\"\" )(#'#(\"'#&'#=.\" 7\u0135"),
    peg$decode("<;\xE5.# &;\xE6=.\" 7\u0137"),
    peg$decode("%;\u0222/V#;\u027C/M$;\u01F3/D$;\u027C/;$;\u01AE/2$;\u027C/)$8&:\u0138&\"%!)(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;n/;#;\u0222/2$;\u027C/)$8#:\u0139#\"\"!)(#'#(\"'#&'#"),
    peg$decode("<%;\u01CC/R#;\xD7/I$;\u027C/@$;\u01CD/7$;\xE9.\" &\"/)$8%:\u013B%\"# )(%'#($'#(#'#(\"'#&'#=.\" 7\u013A"),
    peg$decode("<%;\x9C/7#;\xE9.\" &\"/)$8\":\u013D\"\"! )(\"'#&'#=.\" 7\u013C"),
    peg$decode("<%%;\u01EC/Q#%%<;\u01BF.# &;\u0273=.##&&!&'#/,#;\u027C/#$+\")(\"'#&'#/#$+\")(\"'#&'#.\" &\"/;#;\u01C1/2$;\u027C/)$8#:\u013F#\"\"!)(#'#(\"'#&'#=.\" 7\u013E"),
    peg$decode("<%;\xEB.\" &\"/J#;\u027C/A$;\xEC.\" &\"/3$;\u022B/*$8$:\u0141$##! )($'#(#'#(\"'#&'#=.\" 7\u0140"),
    peg$decode("%;\u0234/1#;\u027C/($8\":\x98\"!!)(\"'#&'#"),
    peg$decode(";\xED.# &;\xEF"),
    peg$decode("%;\u022F.) &;\u0253.# &;\u0218/@#;\u027C/7$;\xEE.\" &\"/)$8#:\u0142#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u0241/1#;\u027C/($8\":\u0143\"!!)(\"'#&'#"),
    peg$decode("%;\u0224.# &;\u01FE/1#;\u027C/($8\":\u0143\"!!)(\"'#&'#"),
    peg$decode("<%;\xF1.# &;\xF2/1#;\u027C/($8\":\u0145\"!!)(\"'#&'#=.\" 7\u0144"),
    peg$decode("<%;\u023D/;#;\u027C/2$;s/)$8#:\u0147#\"\" )(#'#(\"'#&'#=.\" 7\u0146"),
    peg$decode("<%;\u0267/;#;\u027C/2$;\u0107/)$8#:\u0149#\"\" )(#'#(\"'#&'#=.\" 7\u0148"),
    peg$decode("<%;\u0269/;#;\u027C/2$;\u010C/)$8#:\u014B#\"\" )(#'#(\"'#&'#=.\" 7\u014A"),
    peg$decode("%;\xF6/B#;\u027C/9$$;\xF50#*;\xF5&/)$8#:\u014C#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u01CE/:#;\xF6/1$;\u027C/($8#:\u0104#!!)(#'#(\"'#&'#"),
    peg$decode("<%;s/X#;\u027C/O$;\u0151.\" &\"/A$;\u027C/8$;\xF7.\" &\"/*$8%:\u014E%#$\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u014D"),
    peg$decode("%;\u023A/@#;\u027C/7$;\u0214.# &;\u022D/($8#:\u014F#! )(#'#(\"'#&'#"),
    peg$decode("<;\u01D0=.\" 7\u0150"),
    peg$decode("<;\u0250.5 &;\u0254./ &;\u01E4.) &;\u0213.# &;\u021D=.\" 7\u0151"),
    peg$decode("<%;\xFC/k#;\u027C/b$;\u0100/Y$;\u027C/P$;\u0104.\" &\"/B$;\u027C/9$;\xFB.\" &\"/+$8':\u0153'$&$\" )(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u0152"),
    peg$decode("<%;\u0252/:#;\u027C/1$;\xCD/($8#:\u0155#! )(#'#(\"'#&'#=.\" 7\u0154"),
    peg$decode(";\xFD.# &;\xFE"),
    peg$decode("<%;\u0225/@#;\u027C/7$;\xFF.\" &\"/)$8#:\u0157#\"\" )(#'#(\"'#&'#=.\" 7\u0156"),
    peg$decode("<%;\u0250/1#;\u027C/($8\":\u0159\"!!)(\"'#&'#=.\" 7\u0158"),
    peg$decode("<%;\u023F/;#;\u027C/2$;\xF9/)$8#:\u015B#\"\" )(#'#(\"'#&'#=.\" 7\u015A"),
    peg$decode("%;\u0101/2#;\u0103/)$8\":\u015C\"\"! )(\"'#&'#"),
    peg$decode("<%;\u0102/2#;\u01B3/)$8\":\u015E\"\"! )(\"'#&'#=.\" 7\u015D"),
    peg$decode("<%;\u0228/,#;\u027C/#$+\")(\"'#&'#=.\" 7\u015F"),
    peg$decode("<%;\u010A.) &;\x9D.# &;\u010F/1#;\u027C/($8\":\u0160\"!!)(\"'#&'#=.\" 7\u014A"),
    peg$decode("<%;\u0153/j#;\u027C/a$;\u0106.\" &\"/S$;\u027C/J$3\u0162\"\"5\"7\u0163/;$;\u027C/2$;\u0105/)$8':\u0164'\"$ )(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u0161"),
    peg$decode("<%;\u0114/S#;\u027C/J$;\u0116/A$;\u027C/8$;\xD0.\" &\"/*$8%:\u0166%#$\" )(%'#($'#(#'#(\"'#&'#.5 &%3\u0167\"\"5'7\u0168/' 8!:\u0169!! )=.\" 7\u0165"),
    peg$decode("<%;\u014A/@#;\u027C/7$;\xD0.\" &\"/)$8#:\u016B#\"\" )(#'#(\"'#&'#.V &%;\u023D/L#;\u027C/C$;\u01FC/:$;\u027C/1$;\u019B/($8%:\u016C%! )(%'#($'#(#'#(\"'#&'#=.\" 7\u016A"),
    peg$decode("<%;\u01CC/T#;\u0109/K$;\u027C/B$$;\u01080#*;\u0108&/2$;\u01CD/)$8%:\u016E%\"#!)(%'#($'#(#'#(\"'#&'#=.\" 7\u016D"),
    peg$decode("%;\u01CE/:#;\u0109/1$;\u027C/($8#:\u016F#!!)(#'#(\"'#&'#"),
    peg$decode("<%;\u019B/' 8!:\u0171!! )=.\" 7\u0170"),
    peg$decode("<%;\u010B/2#;\u010C/)$8\":\u0172\"\"! )(\"'#&'#=.\" 7\u014A"),
    peg$decode("<%;\u0269/1#;\u027C/($8\":\xC1\"!!)(\"'#&'#=.\" 7\u0173"),
    peg$decode("%;\u010E/B#;\u027C/9$$;\u010D0#*;\u010D&/)$8#:\u0130#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u01CE/:#;\u010E/1$;\u027C/($8#:\x9B#!!)(#'#(\"'#&'#"),
    peg$decode("<%;\u01CC/C#;t/:$;\u027C/1$;\u01CD/($8$:\u0175$!\")($'#(#'#(\"'#&'#=.\" 7\u0174"),
    peg$decode("<%;\u0203/;#;\u027C/2$;\u0269/)$8#:\u0177#\"\" )(#'#(\"'#&'#=.\" 7\u0176"),
    peg$decode("<%;\u0111.) &;\u0227.# &;\u020F/' 8!:\xC1!! )=.\" 7\u0178"),
    peg$decode("<%;\u0264/@#;\u027C/7$;\u0112.\" &\"/)$8#:\u017A#\"\" )(#'#(\"'#&'#=.\" 7\u0179"),
    peg$decode("%;\u01E8/1#;\u027C/($8\":\u017B\"!!)(\"'#&'#"),
    peg$decode("<%;\u0114/\xA2#;\u0115.\" &\"/\x94$;\xE2/\x8B$;\u027C/\x82$;\u0116/y$;\xD0.\" &\"/k$;\xC0.\" &\"/]$;\u027C/T$;\xC1.\" &\"/F$;\u027C/=$;\xFB.\" &\"//$8+:\u017D+(*)(&%$\" )(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u017C"),
    peg$decode("<%;\u0266/1#;\u027C/($8\":\xC1\"!!)(\"'#&'#=.\" 7\u017E"),
    peg$decode("<%;\u023F/C#;\u027C/:$;\xF9/1$;\u027C/($8$:\u0180$!!)($'#(#'#(\"'#&'#=.\" 7\u017F"),
    peg$decode("<%;\u0259/C#;\u027C/:$;\u0117/1$;\u027C/($8$:\u0182$!!)($'#(#'#(\"'#&'#=.\" 7\u0181"),
    peg$decode("%;\u0119/9#$;\u01180#*;\u0118&/)$8\":\u0130\"\"! )(\"'#&'#"),
    peg$decode("%;\u027C/:#;\u01CE/1$;\u0119/($8#:\u016F#! )(#'#(\"'#&'#"),
    peg$decode("<%;\u01A0/M#;\u027C/D$;\u01D8/;$;\u011A/2$;\u027C/)$8%:\u0184%\"$!)(%'#($'#(#'#(\"'#&'#=.\" 7\u0183"),
    peg$decode("<;s.. &%;\u0203/& 8!:\u0186! )=.\" 7\u0185"),
    peg$decode("<%;\u011C/\x80#;\xE2/w$;\u027C/n$;\xD0.\" &\"/`$;\xC0.\" &\"/R$;\xC1.\" &\"/D$;\u027C/;$;\xFB.\" &\"/-$8(:\u0188(&'&$#\" )(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u0187"),
    peg$decode("<%;\u0206/C#;\u027C/:$;\u0217/1$;\u027C/($8$:\xC1$!#)($'#(#'#(\"'#&'#=.\" 7\u0189"),
    peg$decode("<;\u011F.5 &;\u0120./ &;\u0121.) &;\u0122.# &;\u0123=.\" 7\u018A"),
    peg$decode("%;\u01FD/1#;\u027C/($8\":\xC1\"!!)(\"'#&'#"),
    peg$decode("%%<%;\u011E/>#;\u0221./ &;\u0263.) &;\u026A.# &;\u026B/#$+\")(\"'#&'#=.##&&!&'#/1#;\u0124/($8\":\u016F\"! )(\"'#&'#"),
    peg$decode("%%<%;\u011E/>#;\u025D./ &;\u0263.) &;\u026A.# &;\u026B/#$+\")(\"'#&'#=.##&&!&'#/1#;\u0165/($8\":\u016F\"! )(\"'#&'#"),
    peg$decode("%%<%;\u011E/>#;\u025D./ &;\u0221.) &;\u026A.# &;\u026B/#$+\")(\"'#&'#=.##&&!&'#/1#;\u0169/($8\":\u016F\"! )(\"'#&'#"),
    peg$decode("%%<%;\u011E/>#;\u025D./ &;\u0221.) &;\u0263.# &;\u026B/#$+\")(\"'#&'#=.##&&!&'#/1#;\u0178/($8\":\u016F\"! )(\"'#&'#"),
    peg$decode("%%<%;\u011E/>#;\u025D./ &;\u0221.) &;\u0263.# &;\u026A/#$+\")(\"'#&'#=.##&&!&'#/1#;\u017C/($8\":\u016F\"! )(\"'#&'#"),
    peg$decode("<%;\u0125/T#;\u0127.\" &\"/F$;\u019E/=$;\u027C/4$;\u0128/+$8%:\u018C%$$#\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u018B"),
    peg$decode("%;\u011E/J#;\u0126.\" &\"/<$;\u025D/3$;\u027C/*$8$:\u018D$##\"!)($'#(#'#(\"'#&'#"),
    peg$decode("%;\u025F.# &;\u025E/1#;\u027C/($8\":\u018E\"!!)(\"'#&'#"),
    peg$decode("<%;\u021C/N#;\u027C/E$;n/<$;\u0211/3$;\u027C/*$8%:\u0190%#$\"!)(%'#($'#(#'#(\"'#&'#=.\" 7\u018F"),
    peg$decode(";\u0129.# &;\u0164"),
    peg$decode("<%;\u01CC/Z#;\u012B/Q$$;\u012D0#*;\u012D&/A$;\u01CD/8$;\u012A.\" &\"/*$8%:\u0192%##\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u0191"),
    peg$decode("%;\u0270/D#;\u027C/;$;\u0256/2$;\u027C/)$8$:\u0193$\"#!)($'#(#'#(\"'#&'#"),
    peg$decode("%;\u012E/B#;\u027C/9$$;\u012C0#*;\u012C&/)$8#:\u0130#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u01CE/:#;\u012E/1$;\u027C/($8#:\xBB#!!)(#'#(\"'#&'#"),
    peg$decode("%;\u01CE.\" &\"/1#;\u0142/($8\":\u0194\"! )(\"'#&'#"),
    peg$decode("<%;\u012F/O#;\u027C/F$;\u0130.\" &\"/8$;\u0131.\" &\"/*$8$:\u0196$##! )($'#(#'#(\"'#&'#=.\" 7\u0195"),
    peg$decode("%;\u01C1/=#%<;\u027C=/##&'!&&#/($8\":r\"!!)(\"'#&'#.\\ &%%<;\u0130.) &;\u0133.# &;\u0142=.##&&!&'#/:#;\u027C/1$;\u01C4/($8#:r#! )(#'#(\"'#&'#"),
    peg$decode("<%;&/1#;\u027C/($8\":\u0198\"!!)(\"'#&'#=.\" 7\u0197"),
    peg$decode("%;\u0133/B#$;\u01320#*;\u0132&/2$;\u027C/)$8#:\u0130#\"\"!)(#'#(\"'#&'#"),
    peg$decode("%;\u027C/1#;\u0133/($8\":\u016F\"! )(\"'#&'#"),
    peg$decode("<%;\u0134.\" &\"/A#;\u0136/8$;\u0134.\" &\"/*$8#:\u019A##\"! )(#'#(\"'#&'#=.\" 7\u0199"),
    peg$decode("%$;\u0135/&#0#*;\u0135&&&#/' 8!:\u019B!! )"),
    peg$decode("<%;\u01FC/C#;\u027C/:$;\u01C1/1$;\u027C/($8$:\u019D$!!)($'#(#'#(\"'#&'#=.\" 7\u019C"),
    peg$decode(";\u0138.; &;\u013B.5 &;\u013E./ &;\u013F.) &;\u0141.# &;\u0137"),
    peg$decode("<%;\u0157/' 8!:\u019F!! )=.\" 7\u019E"),
    peg$decode("<%;\u0139/U#;\u0151.\" &\"/G$;\u0152.\" &\"/9$;\u013A.\" &\"/+$8$:\u01A1$$#\"! )($'#(#'#(\"'#&'#=.\" 7\u01A0"),
    peg$decode("<%;\u0246.# &;\u0245/D#;\u027C/;$;\u022C/2$;\u027C/)$8$:\u01A3$\"#!)($'#(#'#(\"'#&'#=.\" 7\u01A2"),
    peg$decode("<%;\u01EF/1#;\u027C/($8\":\u01A5\"!!)(\"'#&'#=.\" 7\u01A4"),
    peg$decode("%;\u013C/@#;\u0152.\" &\"/2$;\u027C/)$8#:\u01A6#\"\"!)(#'#(\"'#&'#"),
    peg$decode("<%;\u013D.# &;\u0265/1#;\u027C/($8\":\u0143\"!!)(\"'#&'#=.\" 7\u01A7"),
    peg$decode("<%;n.\" &\"/2#;\u0239/)$8\":\u01A9\"\"! )(\"'#&'#=.\" 7\u01A8"),
    peg$decode("<;\u0154=.\" 7\u01AA"),
    peg$decode("<%;\u0203/D#;\u027C/;$;\u0140/2$;\u027C/)$8$:\u01AC$\"#!)($'#(#'#(\"'#&'#=.\" 7\u01AB"),
    peg$decode(";M./ &;6.) &;,.# &;4"),
    peg$decode("<%;\u014F/' 8!:\u01AE!! )=.\" 7\u01AD"),
    peg$decode("<%;\u0134.\" &\"/J#;\u0143/A$;\u027C/8$;\u0134.\" &\"/*$8$:\u01B0$##\" )($'#(#'#(\"'#&'#=.\" 7\u01AF"),
    peg$decode(";\u0155.) &;\u0145.# &;\u0144"),
    peg$decode("<%;\u0154/' 8!:\u01B2!! )=.\" 7\u01B1"),
    peg$decode("<%;\u0146/J#;\u027C/A$;\u014B/8$;\u0152.\" &\"/*$8$:\u01B4$##! )($'#(#'#(\"'#&'#=.\" 7\u01B3"),
    peg$decode("%;\u0147.# &;\u0148/1#;\u027C/($8\":\u01B5\"!!)(\"'#&'#"),
    peg$decode("<%;\u0246/;#;\u027C/2$;\u022C/)$8#:\u01B6#\"\" )(#'#(\"'#&'#=.\" 7\u01A2"),
    peg$decode("<%;\u0265/' 8!:\u01B8!! )=.\" 7\u01B7"),
    peg$decode("%;\u01CC/T#;\u014D/K$;\u027C/B$$;\u014C0#*;\u014C&/2$;\u01CD/)$8%:\u01B9%\"#!)(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;\u0149/' 8!:\u01BA!! )"),
    peg$decode("%;\u0149/' 8!:\u01BB!! )"),
    peg$decode("%;\u01CE/:#;\u014D/1$;\u027C/($8#:\u016F#!!)(#'#(\"'#&'#"),
    peg$decode("<%;\u014E/O#;\u027C/F$;\u0151.\" &\"/8$;\u013A.\" &\"/*$8$:\u01BD$##! )($'#(#'#(\"'#&'#=.\" 7\u01BC"),
    peg$decode("%;\u0109/\\#%<%;\u027C/8#;\u01DF.) &;\u01CD.# &;\u0151/#$+\")(\"'#&'#=/##&'!&&#/($8\":r\"!!)(\"'#&'#.# &;s"),
    peg$decode("<%$;\u0150/&#0#*;\u0150&&&#/' 8!:\u01BF!! )=.\" 7\u01BE"),
    peg$decode("%;\u01F8/C#;\u027C/:$;\u01AC/1$;\u027C/($8$:r$!!)($'#(#'#(\"'#&'#"),
    peg$decode("<%;\u01ED.# &;\u0207/1#;\u027C/($8\":\u01C1\"!!)(\"'#&'#=.\" 7\u01C0"),
    peg$decode("%;\u0153/;#;\xF9/2$;\u027C/)$8#:\u01C2#\"\"!)(#'#(\"'#&'#"),
    peg$decode("<%;\u023D/D#;\u027C/;$;\u01FB/2$;\u027C/)$8$:\u01C4$\"#!)($'#(#'#(\"'#&'#=.\" 7\u01C3"),
    peg$decode("%;\u01F7/;#;\u027C/2$;M/)$8#:\u01C5#\"\" )(#'#(\"'#&'#"),
    peg$decode("<%;\u0156/E#;\u0107/<$;\u0157/3$;\u027C/*$8$:\u01C7$##\"!)($'#(#'#(\"'#&'#=.\" 7\u01C6"),
    peg$decode("<%;\u0216/D#;\u027C/;$;\u022C/2$;\u027C/)$8$:\u01C9$\"#!)($'#(#'#(\"'#&'#=.\" 7\u01C8"),
    peg$decode("%;\u0158/F#;\u0159.\" &\"/8$;\u0162.\" &\"/*$8#:\u01CA##\"! )(#'#(\"'#&'#"),
    peg$decode("<%;\u024B/D#;\u027C/;$;\u01B3/2$;\u027C/)$8$:\u01CC$\"#!)($'#(#'#(\"'#&'#=.\" 7\u01CB"),
    peg$decode("%;\u015B/B#;\u027C/9$$;\u015A0#*;\u015A&/)$8#:\u01CD#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u015B/1#;\u027C/($8\":\u017B\"!!)(\"'#&'#"),
    peg$decode("<;\u015C.# &;\u0161=.\" 7\u01CE"),
    peg$decode("%;\u023D/T#;\u027C/K$;\u0206.# &;\u0266/<$;\u027C/3$;\u015D/*$8%:\u01CF%#$\" )(%'#($'#(#'#(\"'#&'#"),
    peg$decode("<;\u015E.) &;\u015F.# &;\u0160=.\" 7\u01D0"),
    peg$decode("%;\u0259/J#;\u027C/A$;\u0239.# &;\u0203/2$;\u027C/)$8$:\u01D1$\"#!)($'#(#'#(\"'#&'#"),
    peg$decode("%;\u01F4.# &;\u0251/1#;\u027C/($8\":\u01D2\"!!)(\"'#&'#"),
    peg$decode("%;\u0235/D#;\u027C/;$;\u01E5/2$;\u027C/)$8$:\u01D3$\"#!)($'#(#'#(\"'#&'#"),
    peg$decode("%;\u0233/D#;\u027C/;$;\u01C1/2$;\u027C/)$8$:\u01D4$\"#!)($'#(#'#(\"'#&'#"),
    peg$decode("<%;n.\" &\"/J#;\u0204/A$;\u027C/8$;\u0163.\" &\"/*$8$:\u01D6$##\" )($'#(#'#(\"'#&'#=.\" 7\u01D5"),
    peg$decode("%;\u0223/J#;\u027C/A$;\u0205.# &;\u021F/2$;\u027C/)$8$:\u01D7$\"#!)($'#(#'#(\"'#&'#"),
    peg$decode("%;\u017B/' 8!:\u01D8!! )"),
    peg$decode("<%;\u0166/c#;\u0127.\" &\"/U$;\u01AE/L$;\u027C/C$;\u0168/:$;\xD0.\" &\"/,$8&:\u01DA&%%$#! )(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u01D9"),
    peg$decode("%;\u011E/J#;\u0167.\" &\"/<$;\u0221/3$;\u027C/*$8$:\u01DB$##\"!)($'#(#'#(\"'#&'#"),
    peg$decode("%;\u0265/1#;\u027C/($8\":\u01DC\"!!)(\"'#&'#"),
    peg$decode("<%;\u023D/N#;\u027C/E$;\u019E/<$;\u027C/3$;\u014A/*$8%:\u01DE%#$\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u01DD"),
    peg$decode("<%;\u016A/\xA6#;\u0127.\" &\"/\x98$;\u01AF.\" &\"/\x8A$;\u027C/\x81$;\u016B/x$;\u023D/o$;\u027C/f$;\u019E/]$;\u027C/T$;\u0173.\" &\"/F$;\u0174.\" &\"/8$;\u0175//$8,:\u01E0,(+*)'$\"! )(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u01DF"),
    peg$decode("%;\u011E/J#;\u0126.\" &\"/<$;\u0263/3$;\u027C/*$8$:\u01E1$##\"!)($'#(#'#(\"'#&'#"),
    peg$decode("<%;\u016C.\" &\"/2#;\u016E/)$8\":\u01E3\"\"! )(\"'#&'#=.\" 7\u01E2"),
    peg$decode("%;\u01F0.) &;\u01E7.# &;\u016D/1#;\u027C/($8\":\u01E4\"!!)(\"'#&'#"),
    peg$decode("%;\u0226/;#;\u027C/2$;\u023B/)$8#:\u01E5#\"\" )(#'#(\"'#&'#"),
    peg$decode("<;\u016F.# &;\u0170=.\" 7\u01E6"),
    peg$decode("%;\u0206.# &;\u0225/1#;\u027C/($8\":\u01E7\"!!)(\"'#&'#"),
    peg$decode("%;\u0266/@#;\u027C/7$;\u0171.\" &\"/)$8#:\u01E8#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u023B/;#;\u027C/2$;\u0172/)$8#:\u01E9#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u0109/B#;\u027C/9$$;\u01080#*;\u0108&/)$8#:\u0130#\"\" )(#'#(\"'#&'#"),
    peg$decode("%;\u0215/c#;\u027C/Z$;\u020B/Q$;\u027C/H$;\u0255.) &3\u01EA\"\"5)7\u01EB/3$;\u027C/*$8&:\u01EC&#%#!)(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("<%;\u026C/D#;\u027C/;$;s/2$;\u027C/)$8$:\u01ED$\"#!)($'#(#'#(\"'#&'#=.\" 7\x8A"),
    peg$decode("<%;\u01F1/W#;\u027C/N$;\u0176/E$;\u027C/<$;\u020D/3$;\u027C/*$8&:\u01EF&#%#!)(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u01EE"),
    peg$decode("%$;\u0177/&#0#*;\u0177&&&#/' 8!:\u01F0!! )"),
    peg$decode("%;\x94/:#;\u027C/1$;$/($8#:\"#!\")(#'#(\"'#&'#"),
    peg$decode("<%;\u017A/T#;\u0127.\" &\"/F$;\u0179/=$;\u027C/4$;\u017B/+$8%:\u01F2%$$#\" )(%'#($'#(#'#(\"'#&'#=.\" 7\u01F1"),
    peg$decode("%;\u01B0/;#;\u027C/2$;\u0107/)$8#:\u01F3#\"\" )(#'#(\"'#&'#.# &;\u01B0"),
    peg$decode("%;\u011E/J#;\u0126.\" &\"/<$;\u026A/3$;\u027C/*$8$:\u01F4$##\"!)($'#(#'#(\"'#&'#"),
    peg$decode("%;\u01EC/D#;\u027C/;$;\xB2/2$;\u027C/)$8$:\u0172$\"#!)($'#(#'#(\"'#&'#"),
    peg$decode("<%;\u017D/f#;\u0127.\" &\"/X$;\u019E/O$;\u027C/F$;\u0267/=$;\u027C/4$;\u017E/+$8':\u01F6'$&%$ )(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u01F5"),
    peg$decode("%;\u011E/N#;\u026B/E$;\u027C/<$;\u025D/3$;\u027C/*$8%:\u01F7%#$#!)(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;\u01C3/@#;\u027C/7$;\u017F.\" &\"/)$8#:\u01F8#\"\" )(#'#(\"'#&'#"),
    peg$decode("<%;\u01CC/Z#;\u027C/Q$;\u0180.\" &\"/C$;\u027C/:$;\u01CD/1$;\u027C/($8&:\u01FA&!#)(&'#(%'#($'#(#'#(\"'#&'#=.\" 7\u01F9"),
    peg$decode("%;\u0182/9#$;\u01810#*;\u0181&/)$8\":\u01FB\"\"! )(\"'#&'#"),
    peg$decode("%;\u027C/H#;\u01CE/?$;\u027C/6$;\u0182.\" &\"/($8$:\u01FC$! )($'#(#'#(\"'#&'#"),
    peg$decode("%%<%;\u01C1/;#;\u027C/2$;&.# &;\u0133/#$+#)(#'#(\"'#&'#=.##&&!&'#/:#;s/1$;\u027C/($8#:\u0175#!!)(#'#(\"'#&'#.x &%;\u0183/n#%%<;\u01BF=.##&&!&'#/,#;\u027C/#$+\")(\"'#&'#/F$;\u0130.\" &\"/8$;\u0131.\" &\"/*$8$:\u0196$##! )($'#(#'#(\"'#&'#"),
    peg$decode(";\u01C1.# &;\u01C4"),
    peg$decode("<%;\u0185/;#;\u019E/2$;\u027C/)$8#:\u01FE#\"\"!)(#'#(\"'#&'#=.\" 7\u01FD"),
    peg$decode("<%;\u020A/J#;\u027C/A$;\u0186/8$;\u0187.\" &\"/*$8$:\u0200$##! )($'#(#'#(\"'#&'#=.\" 7\u01FF"),
    peg$decode("<%;\u025D./ &;\u0221.) &;\u0263.# &;\u026A/1#;\u027C/($8\":\u0143\"!!)(\"'#&'#=.\" 7\u0201"),
    peg$decode("<%;\u021C/D#;\u027C/;$;\u0211/2$;\u027C/)$8$:\u0203$\"#!)($'#(#'#(\"'#&'#=.\" 7\u0202"),
    peg$decode("<%;\u01DA/,#;\u01DA/#$+\")(\"'#&'#=.\" 7\u0204"),
    peg$decode("<;\u01D6=.\" 7\u0205"),
    peg$decode("<;\u01D7=.\" 7\u0206"),
    peg$decode("<;\u01D0=.\" 7\u0207"),
    peg$decode("<;\u01E1=.\" 7\u0208"),
    peg$decode("<;\u01DB=.\" 7\u0209"),
    peg$decode("<%;\u01DC/,#;\u01DC/#$+\")(\"'#&'#=.\" 7\u020A"),
    peg$decode("<%;\u01DD/,#;\u01DD/#$+\")(\"'#&'#=.\" 7\u020B"),
    peg$decode("<;\u01D9=.\" 7\u020C"),
    peg$decode("<;\u01DA=.\" 7\u020D"),
    peg$decode("<;\u01DC=.\" 7\u020E"),
    peg$decode("<;\u01DD=.\" 7\u020F"),
    peg$decode("<%;\u01DC/,#;\u01D8/#$+\")(\"'#&'#=.\" 7\u0210"),
    peg$decode("<%;\u01DD/,#;\u01D8/#$+\")(\"'#&'#=.\" 7\u0211"),
    peg$decode("<%;\u01D8/1#;\u01D8.\" &\"/#$+\")(\"'#&'#=.\" 7\u0212"),
    peg$decode("<%;\u01DE/,#;\u01D8/#$+\")(\"'#&'#=.\" 7\u0213"),
    peg$decode("<%;\u01DC/,#;\u01DD/#$+\")(\"'#&'#=.\" 7\u0213"),
    peg$decode("<%$;\u01E3/&#0#*;\u01E3&&&#/<#9:\u0215 ! -\"\"&!&#/($8\":\u0216\"!!)(\"'#&'#=.\" 7\u0214"),
    peg$decode("<%;\u0229/@#;\u027C/7$;n.\" &\"/)$8#:\u0218#\"\" )(#'#(\"'#&'#=.\" 7\u0217"),
    peg$decode("<;\u01C1.# &;\u01C4=.\" 7\u0219"),
    peg$decode("<%;\u019B/' 8!:\u021B!! )=.\" 7\u021A"),
    peg$decode("<%;\u019F.\" &\"/2#;\u019B/)$8\":\u021D\"\"! )(\"'#&'#=.\" 7\u021C"),
    peg$decode("<%;\u019F.\" &\"/2#;\u019B/)$8\":\u021F\"\"! )(\"'#&'#=.\" 7\u021E"),
    peg$decode("%;\u019B/2#;\u01CF/)$8\":\u0220\"\"! )(\"'#&'#"),
    peg$decode("<%;\u01AA.) &;\u01AB.# &;\u01A9/J#;\u019B/A$;\u027C/8$;\u01A1.\" &\"/*$8$:\u0222$##\" )($'#(#'#(\"'#&'#=.\" 7\u0221"),
    peg$decode("<%;\u01A2/' 8!:\u0224!! )=.\" 7\u0223"),
    peg$decode("%;\u01A3/B#;\u027C/9$$;\u01A30#*;\u01A3&/)$8#:\u0225#\"\" )(#'#(\"'#&'#"),
    peg$decode(";\u01A4.) &;\u01A5.# &;\u01A6"),
    peg$decode("%;\u01CF/:#;\u027C/1$;\u01C1/($8#:\u0226#! )(#'#(\"'#&'#.D &%;\u01CF/:#;\u027C/1$;\u01D0/($8#:\u0227#! )(#'#(\"'#&'#"),
    peg$decode("%;\u01CA/r#;\u027C/i$;\u01A7.\" &\"/[$;\u01E0/R$;\u027C/I$;\u01A8.\" &\"/;$;\u027C/2$;\u01CB/)$8(:\u0228(\"%\")(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.m &%;\u01CA/c#;\u027C/Z$;\u01E0/Q$;\u027C/H$;\u01A8.\" &\"/:$;\u027C/1$;\u01CB/($8':\u0229'!\")(''#(&'#(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;\u01CA/L#;\u027C/C$;s/:$;\u027C/1$;\u01CB/($8%:\u022A%!\")(%'#($'#(#'#(\"'#&'#"),
    peg$decode("%;s/' 8!:\u022B!! )"),
    peg$decode("%;s/' 8!:\u022C!! )"),
    peg$decode("%;\u027C/& 8!:\u022D! )"),
    peg$decode("%;\u019F/2#;\u01AB/)$8\":\u022E\"\"! )(\"'#&'#"),
    peg$decode("%;\u019B/2#;\u01CF/)$8\":F\"\"! )(\"'#&'#"),
    peg$decode("<%;\u019B/' 8!:\u0230!! )=.\" 7\u022F"),
    peg$decode("<%;\u019B/' 8!:\u0232!! )=.\" 7\u0231"),
    peg$decode("<%;\u019F.\" &\"/2#;\u019B/)$8\":\u0234\"\"! )(\"'#&'#=.\" 7\u0233"),
    peg$decode("<%;\u019F.\" &\"/2#;\u019B/)$8\":\u0236\"\"! )(\"'#&'#=.\" 7\u0235"),
    peg$decode("<%;\u019F.\" &\"/2#;\u019B/)$8\":\u0238\"\"! )(\"'#&'#=.\" 7\u0237"),
    peg$decode("<%;\u019F.\" &\"/2#;\u019B/)$8\":\u023A\"\"! )(\"'#&'#=.\" 7\u0239"),
    peg$decode("<%;\u019F.\" &\"/2#;\u019B/)$8\":\u023C\"\"! )(\"'#&'#=.\" 7\u023B"),
    peg$decode("<%;\u01B4.# &;\u019E/1#;\u027C/($8\":\u023E\"!!)(\"'#&'#=.\" 7\u023D"),
    peg$decode("%;\u019E/;#;\u027C/2$;\u0107/)$8#:\u023F#\"\" )(#'#(\"'#&'#"),
    peg$decode("<%;\u019B/' 8!:\u0241!! )=.\" 7\u0240"),
    peg$decode("<%;\u019B/' 8!:\u0243!! )=.\" 7\u0242"),
    peg$decode("<%;\u01B8/=#%<;\u01BF=.##&&!&'#/($8\":\u0245\"!!)(\"'#&'#.\xC5 &%;\u01B9/=#%<;\u01BF=.##&&!&'#/($8\":\u0246\"!!)(\"'#&'#.\x9B &%;\u01BB/=#%<;\u01BF=.##&&!&'#/($8\":\u0247\"!!)(\"'#&'#.q &%;\u01BC/=#%<;\u01BF=.##&&!&'#/($8\":\u0248\"!!)(\"'#&'#.G &%;\u01BE/=#%<;\u01BF=.##&&!&'#/($8\":\u0249\"!!)(\"'#&'#=.\" 7\u0244"),
    peg$decode("<%%3\u024B\"\"5!7\u024C.\" &\"/F#3\u024D\"\"5#7\u024E.\" &\"/2$3\u024F\"\"5$7\u0250/#$+#)(#'#(\"'#&'#.k &%3\u0251\"\"5$7\u0252.5 &3\u0253\"\"5&7\u0254.) &3\u0255\"\"5$7\u0256.\" &\"/2#3\u0257\"\"5$7\u0258/#$+\")(\"'#&'#.) &3\u0259\"\"5$7\u025A/' 8!:\u0143!! )=.\" 7\u024A"),
    peg$decode("<%;\u01BA.5 &3\u025C\"\"5%7\u025D.) &3\u025E\"\"5$7\u025F/' 8!:\u0143!! )=.\" 7\u025B"),
    peg$decode("<%3\u0261\"\"5&7\u0262/i#%$4(\"\"5!7)/,#0)*4(\"\"5!7)&&&#/2#3\u0263\"\"5)7\u0264/#$+\")(\"'#&'#.\" &\"/)$8\":\u0265\"\"! )(\"'#&'#=.\" 7\u0260"),
    peg$decode("<%3\u0267\"\"5'7\u0268.\x95 &3\u0269\"\"5'7\u026A.\x89 &3\u026B\"\"5'7\u026C.} &%3\u026D\"\"5$7\u026E/7#3\xD7\"\"5$7\xD8.\" &\"/#$+\")(\"'#&'#.S &%3\xD7\"\"5$7\xD8/7#3\u026F\"\"5%7\u0270.\" &\"/#$+\")(\"'#&'#.) &3\u0271\"\"5&7\u0272/' 8!:\u0143!! )=.\" 7\u0266"),
    peg$decode("<%%3\u0274\"\"5#7\u0275/V#2\u0276\"\"6\u02767\u0277.A &2\u0278\"\"6\u02787\u0279.5 &2\u027A\"\"6\u027A7\u027B.) &3\u027C\"\"5$7\u027D/#$+\")(\"'#&'#.q &%3\u027E\"\"5#7\u027F.A &3\u0253\"\"5&7\u0254.5 &3\u0280\"\"5%7\u0281.) &3\u0251\"\"5$7\u0252.\" &\"/2#3\u0274\"\"5#7\u0275/#$+\")(\"'#&'#.# &;\u01BD/' 8!:\u0143!! )=.\" 7\u0273"),
    peg$decode("%3\u0282\"\"5(7\u0283/d#%$4(\"\"5!7)/,#0)*4(\"\"5!7)&&&#/2#3\u0284\"\"5%7\u0285/#$+\")(\"'#&'#/)$8\":\u0286\"\"! )(\"'#&'#"),
    peg$decode("<%3\u0288\"\"5$7\u0289/' 8!:\u0143!! )=.\" 7\u0287"),
    peg$decode("4\u028A\"\"5!7\u028B"),
    peg$decode("%2\u028C\"\"6\u028C7\u028D/K#$4\u028E\"\"5!7\u028F/,#0)*4\u028E\"\"5!7\u028F&&&#/)$8\":\u0290\"\"! )(\"'#&'#"),
    peg$decode(";\u01C2.# &;\u01C3"),
    peg$decode(";\u01C5./ &;\u01C9.) &;\u01C7.# &;\u01C8"),
    peg$decode("%%<;\u0271.# &;?=.##&&!&'#/J#$;\u01C0.# &;\u01BF/,#0)*;\u01C0.# &;\u01BF&&&#/($8\":\xFC\"! )(\"'#&'#"),
    peg$decode("%%<;\u0273.# &;?=.##&&!&'#/J#$;\u01C0.# &;\u01BF/,#0)*;\u01C0.# &;\u01BF&&&#/($8\":\u0291\"! )(\"'#&'#"),
    peg$decode("%;\u01CA/\x99#;\u027C/\x90$%$%%<;\u01C6=.##&&!&'#/1#1\"\"5!7\u0292/#$+\")(\"'#&'#0G*%%<;\u01C6=.##&&!&'#/1#1\"\"5!7\u0292/#$+\")(\"'#&'#&/\"!&,)/1$;\u01C6/($8$:\u0293$!!)($'#(#'#(\"'#&'#"),
    peg$decode("%$4\u0294\"\"5!7\u02950)*4\u0294\"\"5!7\u0295&/5#;\u01CB/,$;\u027C/#$+#)(#'#(\"'#&'#"),
    peg$decode("%2\u0296\"\"6\u02967\u0297/k#$2\u0298\"\"6\u02987\u0299.) &4\u029A\"\"5!7\u029B05*2\u0298\"\"6\u02987\u0299.) &4\u029A\"\"5!7\u029B&/7$2\u0296\"\"6\u02967\u0297/($8#:\u029C#!!)(#'#(\"'#&'#"),
    peg$decode("%2\u029D\"\"6\u029D7\u029E/k#$26\"\"6677.) &48\"\"5!7905*26\"\"6677.) &48\"\"5!79&/7$2\u029D\"\"6\u029D7\u029E/($8#:\u029F#!!)(#'#(\"'#&'#"),
    peg$decode("%2\u02A0\"\"6\u02A07\u02A1/k#$2\u02A2\"\"6\u02A27\u02A3.) &4\u02A4\"\"5!7\u02A505*2\u02A2\"\"6\u02A27\u02A3.) &4\u02A4\"\"5!7\u02A5&/7$2\u02A0\"\"6\u02A07\u02A1/($8#:\u02A6#!!)(#'#(\"'#&'#"),
    peg$decode("<%2\u02A8\"\"6\u02A87\u02A9/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02A7"),
    peg$decode("<%2\u02AB\"\"6\u02AB7\u02AC/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02AA"),
    peg$decode("<%2\u02AE\"\"6\u02AE7\u02AF/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02AD"),
    peg$decode("<%2\u02B1\"\"6\u02B17\u02B2/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02B0"),
    peg$decode("<%2\u02B4\"\"6\u02B47\u02B5/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02B3"),
    peg$decode("<%2\u02B7\"\"6\u02B77\u02B8/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02B6"),
    peg$decode("<%2\u02BA\"\"6\u02BA7\u02BB/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02B9"),
    peg$decode("<%2\u02BD\"\"6\u02BD7\u02BE/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02BC"),
    peg$decode("<%2\u029D\"\"6\u029D7\u029E/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02BF"),
    peg$decode("<%2\u0296\"\"6\u02967\u0297/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02C0"),
    peg$decode("<%2\u02A0\"\"6\u02A07\u02A1/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02C1"),
    peg$decode("<%2\u02C3\"\"6\u02C37\u02C4/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02C2"),
    peg$decode("<%2\u02C6\"\"6\u02C67\u02C7/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02C5"),
    peg$decode("<%2\u02C9\"\"6\u02C97\u02CA/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02C8"),
    peg$decode("<%2\u02CB\"\"6\u02CB7\u02CC/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u0212"),
    peg$decode("<%2\u02CE\"\"6\u02CE7\u02CF/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02CD"),
    peg$decode("<%2\u02D1\"\"6\u02D17\u02D2/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02D0"),
    peg$decode("<%2\u02D3\"\"6\u02D37\u02D4/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u0209"),
    peg$decode("<%2\u02D5\"\"6\u02D57\u02D6/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u020E"),
    peg$decode("<%2\u02D7\"\"6\u02D77\u02D8/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u020F"),
    peg$decode("<%2\u02DA\"\"6\u02DA7\u02DB/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02D9"),
    peg$decode("<%2\u02DD\"\"6\u02DD7\u02DE/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02DC"),
    peg$decode("<%2c\"\"6c7d/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02DF"),
    peg$decode("<%2\u02E1\"\"6\u02E17\u02E2/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02E0"),
    peg$decode("<%2\u02E4\"\"6\u02E47\u02E5/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02E3"),
    peg$decode("<%4\u02E7\"\"5!7\u02E8/1#;\u027C/($8\":\"\"!!)(\"'#&'#=.\" 7\u02E6"),
    peg$decode("%3\u02E9\"\"5%7\u02EA/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02EB\"\"5&7\u02EC/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02ED\"\"5#7\u02EE/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02EF\"\"5%7\u02F0/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\xE8\"\"5#7\xE9/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02F1\"\"5%7\u02F2/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02F3\"\"5'7\u02F4/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02F5\"\"5#7\u02F6/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02F7\"\"5\"7\u02F8/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02F9\"\"5#7\u02FA/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02FB\"\"5&7\u02FC/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02FD\"\"5-7\u02FE/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u02FF\"\"5&7\u0300/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0301\"\"5%7\u0302/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0303\"\"5'7\u0304/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0305\"\"5\"7\u0306/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0307\"\"5'7\u0308/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0309\"\"5$7\u030A/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u030B\"\"5$7\u030C/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u030D\"\"5%7\u030E/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u030F\"\"5'7\u0310/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0311\"\"5&7\u0312/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0313\"\"5&7\u0314/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0315\"\"5(7\u0316/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0317\"\"5*7\u0318/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0319\"\"5&7\u031A/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u031B\"\"5%7\u031C/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u031D\"\"5,7\u031E/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u031F\"\"5,7\u0320/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0321\"\"517\u0322/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0323\"\"5(7\u0324/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0325\"\"5'7\u0326/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0327\"\"5*7\u0328/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0329\"\"5(7\u032A/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u032B\"\"5&7\u032C/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u032D\"\"5$7\u032E/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u032F\"\"5&7\u0330/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0331\"\"5(7\u0332/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0333\"\"5$7\u0334/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0335\"\"5$7\u0336/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0337\"\"5$7\u0338/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0339\"\"5#7\u033A/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u033B\"\"5&7\u033C/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u033D\"\"5&7\u033E/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u033F\"\"5)7\u0340/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0341\"\"5&7\u0342/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0343\"\"5'7\u0344/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0345\"\"5$7\u0346/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0347\"\"5%7\u0348/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0349\"\"5#7\u034A/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u034B\"\"5'7\u034C/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u034D\"\"5$7\u034E/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u034F\"\"5$7\u0350/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0351\"\"5$7\u0352/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0353\"\"5%7\u0354/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0355\"\"5&7\u0356/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0357\"\"5\"7\u0358/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0359\"\"5&7\u035A/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u035B\"\"5%7\u035C/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u035D\"\"5)7\u035E/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u035F\"\"5\"7\u0360/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0361\"\"5%7\u0362/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0363\"\"5'7\u0364/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0365\"\"5)7\u0366/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0367\"\"5%7\u0368/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0369\"\"5&7\u036A/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u036B\"\"5'7\u036C/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u036D\"\"5)7\u036E/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u036F\"\"5$7\u0370/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0371\"\"5\"7\u0372/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0373\"\"5&7\u0374/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0375\"\"5$7\u0376/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0377\"\"5#7\u0378/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0379\"\"5$7\u037A/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u037B\"\"5'7\u037C/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u037D\"\"5$7\u037E/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u037F\"\"5$7\u0380/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0381\"\"5%7\u0382/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0383\"\"5&7\u0384/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0385\"\"5%7\u0386/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0387\"\"5'7\u0388/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0389\"\"5\"7\u038A/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u038B\"\"5#7\u038C/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u038D\"\"5'7\u038E/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u038F\"\"5&7\u0390/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\x7F\"\"5$7\x80/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0391\"\"5%7\u0392/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0393\"\"5\"7\u0394/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0395\"\"5&7\u0396/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0397\"\"5\"7\u0398/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u0399\"\"5$7\u039A/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u039B\"\"5\"7\u039C/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u039D\"\"5%7\u039E/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u039F\"\"5%7\u03A0/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03A1\"\"5$7\u03A2/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03A3\"\"5)7\u03A4/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03A5\"\"5$7\u03A6/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03A7\"\"5&7\u03A8/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03A9\"\"5'7\u03AA/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03AB\"\"5%7\u03AC/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03AD\"\"5%7\u03AE/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03AF\"\"5$7\u03B0/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03B1\"\"5)7\u03B2/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03B3\"\"5*7\u03B4/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03B5\"\"5&7\u03B6/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03B7\"\"5'7\u03B8/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03B9\"\"5'7\u03BA/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03BB\"\"5&7\u03BC/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03BD\"\"5'7\u03BE/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03BF\"\"5(7\u03C0/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03C1\"\"5)7\u03C2/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03C3\"\"5%7\u03C4/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03C5\"\"5(7\u03C6/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03C7\"\"5#7\u03C8/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03C9\"\"5%7\u03CA/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03CB\"\"5)7\u03CC/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03CD\"\"5&7\u03CE/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03CF\"\"5#7\u03D0/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03D1\"\"5%7\u03D2/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03D3\"\"5$7\u03D4/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03D5\"\"5$7\u03D6/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03D7\"\"5%7\u03D8/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03D9\"\"5$7\u03DA/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03DB\"\"5)7\u03DC/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03DD\"\"5$7\u03DE/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03DF\"\"5\"7\u03E0/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\xDC\"\"5+7\xDD/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03E1\"\"5'7\u03E2/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03E3\"\"5%7\u03E4/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03E5\"\"5&7\u03E6/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03E7\"\"5&7\u03E8/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03E9\"\"5%7\u03EA/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03EB\"\"5&7\u03EC/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03ED\"\"5&7\u03EE/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03EF\"\"5$7\u03F0/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03F1\"\"5'7\u03F2/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03F3\"\"5$7\u03F4/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03F5\"\"5%7\u03F6/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03F7\"\"5&7\u03F8/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03F9\"\"5$7\u03FA/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%3\u03FB\"\"5'7\u03FC/8#%<;\u01BF=.##&&!&'#/#$+\")(\"'#&'#"),
    peg$decode("%;\u0272/' 8!:\u03FD!! )"),
    peg$decode(";\u01E4.\u034D &;\u01E5.\u0347 &;\u01E6.\u0341 &;\u01E7.\u033B &;\u01E8.\u0335 &;\u01E9.\u032F &;\u01EA.\u0329 &;\u01EB.\u0323 &;\u01EC.\u031D &;\u01ED.\u0317 &;\u01EE.\u0311 &;\u01EF.\u030B &;\u01F0.\u0305 &;\u01F1.\u02FF &;\u01F2.\u02F9 &;\u01F3.\u02F3 &;\u01F4.\u02ED &;\u01F5.\u02E7 &;\u01F6.\u02E1 &;\u01F7.\u02DB &;\u01F8.\u02D5 &;\u01F9.\u02CF &;\u01FA.\u02C9 &;\u01FB.\u02C3 &;\u01FC.\u02BD &;\u01FD.\u02B7 &;\u01FE.\u02B1 &;\u01FF.\u02AB &;\u0200.\u02A5 &;\u0201.\u029F &;\u0202.\u0299 &;\u0203.\u0293 &;\u0204.\u028D &;\u0205.\u0287 &;\u0206.\u0281 &;\u0207.\u027B &;\u0208.\u0275 &;\u0209.\u026F &;\u020A.\u0269 &;\u020B.\u0263 &;\u020C.\u025D &;\u020D.\u0257 &;\u020E.\u0251 &;\u020F.\u024B &;\u0210.\u0245 &;\u0211.\u023F &;\u0212.\u0239 &;\u0213.\u0233 &;\u0214.\u022D &;\u0215.\u0227 &;\u0216.\u0221 &;\u0217.\u021B &;\u0218.\u0215 &;\u0219.\u020F &;\u021A.\u0209 &;\u021B.\u0203 &;\u021C.\u01FD &;\u021D.\u01F7 &;\u021E.\u01F1 &;\u021F.\u01EB &;\u0220.\u01E5 &;\u0221.\u01DF &;\u0222.\u01D9 &;\u0223.\u01D3 &;\u0224.\u01CD &;\u0225.\u01C7 &;\u0226.\u01C1 &;\u0227.\u01BB &;\u0228.\u01B5 &;\u0229.\u01AF &;\u022A.\u01A9 &;\u022B.\u01A3 &;\u022C.\u019D &;\u022D.\u0197 &;\u022F.\u0191 &;\u0230.\u018B &;\u0231.\u0185 &;\u0232.\u017F &;\u0233.\u0179 &;\u0234.\u0173 &;\u0235.\u016D &;\u0236.\u0167 &;\u0237.\u0161 &;\u0238.\u015B &;\u0239.\u0155 &;\u023A.\u014F &;\u023B.\u0149 &;\u023C.\u0143 &;\u023D.\u013D &;\u023E.\u0137 &;\u023F.\u0131 &;\u0240.\u012B &;\u0241.\u0125 &;\u0242.\u011F &;\u0243.\u0119 &;\u0244.\u0113 &;\u0245.\u010D &;\u0246.\u0107 &;\u0247.\u0101 &;\u0248.\xFB &;\u0249.\xF5 &;\u024A.\xEF &;\u024B.\xE9 &;\u024C.\xE3 &;\u024D.\xDD &;\u024E.\xD7 &;\u024F.\xD1 &;\u0250.\xCB &;\u0251.\xC5 &;\u0252.\xBF &;\u0253.\xB9 &;\u0254.\xB3 &;\u0257.\xAD &;\u0258.\xA7 &;\u0259.\xA1 &;\u025A.\x9B &;\u025B.\x95 &;\u025C.\x8F &;\u025D.\x89 &;\u025F.\x83 &;\u0260.} &;\u0261.w &;\u0262.q &;\u0263.k &;\u0264.e &;\u0265._ &;\u0266.Y &;\u0267.S &;\u0268.M &;\u0269.G &;\u026A.A &;\u026B.; &;\u026C.5 &;\u026D./ &;\u026E.) &;\u026F.# &;\u0270"),
    peg$decode(";\u01E6.\u0167 &;\u01E8.\u0161 &;\u01E9.\u015B &;\u01EB.\u0155 &;\u01EC.\u014F &;\u01EF.\u0149 &;\u01F2.\u0143 &;\u01F5.\u013D &;\u01F7.\u0137 &;\u01F8.\u0131 &;\u01FA.\u012B &;\u01FC.\u0125 &;\u01FD.\u011F &;\u0203.\u0119 &;\u0204.\u0113 &;\u0206.\u010D &;\u0209.\u0107 &;\u020A.\u0101 &;\u020C.\xFB &;\u020E.\xF5 &;\u020F.\xEF &;\u0211.\xE9 &;\u0216.\xE3 &;\u0217.\xDD &;\u021A.\xD7 &;\u021B.\xD1 &;\u0220.\xCB &;\u0221.\xC5 &;\u0225.\xBF &;\u0227.\xB9 &;\u0228.\xB3 &;\u0229.\xAD &;\u022A.\xA7 &;\u022B.\xA1 &;\u0231.\x9B &;\u0236.\x95 &;\u0237.\x8F &;\u0239.\x89 &;\u023D.\x83 &;\u023F.} &;\u0240.w &;\u0246.q &;\u024B.k &;\u0258.e &;\u0259._ &;\u025D.Y &;\u0260.S &;\u0261.M &;\u0262.G &;\u0264.A &;\u0265.; &;\u0266.5 &;\u0267./ &;\u0269.) &;\u026C.# &;\u026D"),
    peg$decode(";\u0275.. &%;\u0276/& 8!:\u03FE! )"),
    peg$decode("<%2\u0400\"\"6\u04007\u0401/\x87#$%%<4\u0402\"\"5!7\u0403=.##&&!&'#/1#1\"\"5!7\u0292/#$+\")(\"'#&'#0M*%%<4\u0402\"\"5!7\u0403=.##&&!&'#/1#1\"\"5!7\u0292/#$+\")(\"'#&'#&/#$+\")(\"'#&'#=.\" 7\u03FF"),
    peg$decode("<%;\u0277/5#;\u027B/,$;\u0278/#$+#)(#'#(\"'#&'#=.\" 7\u0404"),
    peg$decode("2\u0405\"\"6\u04057\u0406"),
    peg$decode("2\u0407\"\"6\u04077\u0408"),
    peg$decode("$%%<;\u0278.# &;\u0277=.##&&!&'#/1#1\"\"5!7\u0292/#$+\")(\"'#&'#/P#0M*%%<;\u0278.# &;\u0277=.##&&!&'#/1#1\"\"5!7\u0292/#$+\")(\"'#&'#&&&#"),
    peg$decode(";\u0279.# &;\u0276"),
    peg$decode("%;\u027A/K#$4\u0409\"\"5!7\u040A.# &;\u027A0/*4\u0409\"\"5!7\u040A.# &;\u027A&/#$+\")(\"'#&'#"),
    peg$decode("<%$4\u0409\"\"5!7\u040A.# &;\u02740/*4\u0409\"\"5!7\u040A.# &;\u0274&/' 8!:-!! )=.\" 7\u040B"),
    peg$decode("2\u040C\"\"6\u040C7\u040D")
  ];

  var peg$currPos = 0;
  var peg$savedPos = 0;
  var peg$posDetailsCache = [{ line: 1, column: 1 }];
  var peg$maxFailPos = 0;
  var peg$maxFailExpected = [];
  var peg$silentFails = 0;

  var peg$resultsCache = {};

  var peg$ruleNames = ["start", "start_streaming", "stmt_list", "semi_optional", "semi_required", "stmt_list_tail", "type_definition", "type_definition_types", "datatype_custom", "datatype_word_tail", "type_definition_args", "definition_args_loop", "literal_value", "literal_null", "literal_date", "literal_string", "literal_string_single", "literal_string_schar", "literal_blob", "literal_typed", "literal_text", "number_sign", "literal_number_signed", "literal_number", "literal_number_decimal", "number_decimal_node", "number_decimal_full", "number_decimal_fraction", "number_decimal_exponent", "literal_number_hex", "number_hex", "number_digit", "bind_parameter", "bind_parameter_numbered", "bind_number_id", "bind_parameter_named", "bind_parameter_tcl", "tcl_suffix", "expression_exists", "expression_exists_ne", "expression_raise", "expression_raise_args", "raise_args_ignore", "raise_args_message", "expression_root", "expression_wrapped", "expression_recur", "expression_unary_collate", "expression_pg_cast", "expression_unary", "expression_unary_op", "expression_collate", "expression_concat", "expression_multiply", "expression_multiply_op", "expression_add", "expression_add_op", "expression_shift", "expression_shift_op", "expression_compare", "expression_compare_op", "expression_equiv", "expression_equiv_tails", "expression_equiv_null_op", "expression_equiv_op", "expression_cast", "type_alias", "expression_case", "case_expression", "expression_case_when", "expression_case_else", "expression_postfix", "expression_postfix_tail", "expression_distinct", "expression_like", "expression_escape", "expression_between", "expression_between_tail", "expression_is_not", "expression_in", "expression_in_target", "expression_list_or_select", "expression_and", "expression", "expression_list", "expression_list_loop", "expression_list_rest", "function_call", "function_call_args", "args_list_distinct", "over_clause", "window_name", "window_specification", "source_window_name", "partition_clause", "error_message", "stmt", "stmt_modifier", "modifier_query", "stmt_nodes", "stmt_commit", "stmt_begin", "commit_transaction", "stmt_begin_modifier", "stmt_rollback", "rollback_savepoint", "savepoint_name", "savepoint_alt", "stmt_savepoint", "stmt_release", "stmt_alter", "alter_start", "alter_action", "alter_action_rename", "alter_action_add", "action_add_modifier", "stmt_crud", "stmt_core_with", "clause_with", "clause_with_recursive", "clause_with_tables", "clause_with_loop", "expression_cte", "select_alias", "select_wrapped", "stmt_select_full", "stmt_show", "show_target", "stmt_sqlite", "stmt_attach", "attach_arg", "stmt_detach", "stmt_vacuum", "vacuum_target", "stmt_analyze", "analyze_arg", "stmt_reindex", "reindex_arg", "stmt_pragma", "pragma_expression", "pragma_value", "pragma_value_literal", "pragma_value_bool", "pragma_bool_id", "pragma_value_name", "stmt_crud_types", "stmt_select", "stmt_core_for_locking", "for_locking_items", "for_locking_loop", "for_locking_item", "for_locking_strength", "locked_rels_list", "id_table_list", "id_table_loop", "nowait_or_skip", "window_clause", "window_definition_list", "window_definition_loop", "window_definition", "stmt_core_order", "stmt_core_limit", "stmt_core_limit_offset", "limit_offset_variant", "limit_offset_variant_name", "select_loop", "select_loop_union", "select_parts", "select_parts_core", "select_core_select", "select_modifier", "select_modifier_distinct", "select_modifier_all", "select_target", "select_target_loop", "select_core_from", "stmt_core_where", "select_core_group", "select_core_having", "select_node", "select_node_star", "select_node_star_qualified", "select_node_aliased", "select_source", "source_loop_tail", "select_cross_clause", "select_join_clause", "table_or_sub", "table_or_sub_func", "func_alias_clause", "table_func_element_list", "table_func_element", "table_func_element_tail", "lateral", "table_qualified", "table_qualified_id", "table_or_sub_index_node", "index_node_indexed", "index_node_none", "table_or_sub_sub", "table_or_sub_select", "alias", "join_operator", "join_operator_natural", "join_operator_types", "operator_types_hand", "types_hand_outer", "operator_types_misc", "join_condition", "join_condition_on", "join_condition_using", "select_parts_values", "stmt_core_order_list", "stmt_core_order_list_loop", "stmt_core_order_list_item", "nulls_order", "select_star", "stmt_fallback_types", "stmt_insert", "returning_clause", "insert_keyword", "insert_keyword_ins", "insert_keyword_repl", "insert_keyword_mod", "insert_target", "insert_into", "insert_into_start", "insert_results", "opt_on_conflict", "opt_on_conflict_action", "opt_conf_expr", "loop_columns", "loop_column_tail", "loop_name", "insert_value", "insert_value_start", "insert_values_list", "insert_values_loop", "expression_list_wrapped", "insert_default", "operator_compound", "compound_union", "compound_union_all", "stmt_update", "update_start", "update_fallback", "update_set", "update_columns", "update_columns_tail", "update_column", "update_expression", "stmt_delete", "delete_start", "stmt_create", "create_start", "create_table_only", "create_index_only", "create_trigger_only", "create_view_only", "create_virtual_only", "create_table", "create_table_start", "create_core_tmp", "create_core_ine", "create_table_source", "table_source_def", "source_def_rowid", "source_def_loop", "source_def_tail", "source_tbl_loop", "source_def_column", "source_def_name", "column_type", "column_constraints", "column_constraint_tail", "column_constraint", "constraint_name", "constraint_name_loop", "column_constraint_types", "column_constraint_foreign", "column_constraint_primary", "col_primary_start", "col_primary_auto", "column_constraint_null", "constraint_null_types", "constraint_null_value", "column_constraint_check", "column_constraint_default", "column_default_values", "column_constraint_collate", "table_constraint", "table_constraint_types", "table_constraint_check", "table_constraint_primary", "primary_start", "primary_start_normal", "primary_start_unique", "primary_columns", "primary_columns_index", "primary_columns_table", "primary_column_tail", "primary_column", "primary_column_types", "column_collate", "column_collate_loop", "primary_column_dir", "primary_conflict", "primary_conflict_start", "constraint_check", "table_constraint_foreign", "foreign_start", "foreign_clause", "foreign_references", "foreign_actions", "foreign_actions_tail", "foreign_action", "foreign_action_on", "action_on_action", "on_action_set", "on_action_cascade", "on_action_none", "foreign_action_match", "foreign_deferrable", "deferrable_initially", "table_source_select", "create_index", "create_index_start", "index_unique", "index_on", "create_trigger", "create_trigger_start", "trigger_conditions", "trigger_apply_mods", "trigger_apply_instead", "trigger_do", "trigger_do_on", "trigger_do_update", "do_update_of", "do_update_columns", "trigger_foreach", "trigger_when", "trigger_action", "action_loop", "action_loop_stmt", "create_view", "id_view_expression", "create_view_start", "create_as_select", "create_virtual", "create_virtual_start", "virtual_module", "virtual_args", "virtual_args_loop", "virtual_args_tail", "virtual_arg_types", "virtual_column_name", "stmt_drop", "drop_start", "drop_types", "drop_ie", "binary_concat", "binary_plus", "binary_minus", "binary_multiply", "binary_divide", "binary_mod", "binary_left", "binary_right", "binary_and", "binary_or", "binary_lt", "binary_gt", "binary_lte", "binary_gte", "binary_equal", "binary_notequal_a", "binary_notequal_b", "binary_custom", "binary_lang_isnt", "id_name", "id_database", "id_function", "id_table", "id_table_qualified", "id_column", "indirection", "indirection_loop", "indirection_el", "indirection_attr", "indirection_slice", "indirection_index", "slice_lbound", "slice_ubound", "column_unqualified", "column_qualifiers", "id_column_qualified", "id_collation", "id_savepoint", "id_index", "id_trigger", "id_view", "id_pragma", "id_variable", "id_cte", "id_table_expression", "id_constraint_table", "id_constraint_column", "datatype_types", "datatype_text", "datatype_real", "datatype_real_double", "datatype_numeric", "datatype_integer", "datatype_integer_fp", "datatype_none", "name_char", "unicode_char", "name", "name_quoted", "name_unquoted", "name_reserved", "name_bracketed", "bracket_terminator", "name_dblquoted", "name_sglquoted", "name_backticked", "sym_bopen", "sym_bclose", "sym_popen", "sym_pclose", "sym_comma", "sym_dot", "sym_star", "sym_quest", "sym_sglquote", "sym_dblquote", "sym_backtick", "sym_tilde", "sym_plus", "sym_minus", "sym_equal", "sym_amp", "sym_pipe", "sym_mod", "sym_lt", "sym_gt", "sym_excl", "sym_semi", "sym_colon", "sym_fslash", "sym_bslash", "sym_op", "ABORT", "ACTION", "ADD", "AFTER", "ALL", "ALTER", "ANALYZE", "AND", "AS", "ASC", "ATTACH", "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN", "BY", "CASCADE", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN", "COMMIT", "CONFLICT", "CONSTRAINT", "CREATE", "CROSS", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE", "DESC", "DETACH", "DISTINCT", "DROP", "EACH", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUSIVE", "EXISTS", "EXPLAIN", "FAIL", "FIRST", "FOR", "FOREIGN", "FROM", "FULL", "GLOB", "GROUP", "HAVING", "IF", "IGNORE", "ILIKE", "IMMEDIATE", "IN", "INDEX", "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", "KEY", "LAST", "LATERAL", "LEFT", "LIKE", "LIMIT", "LOCKED", "MATCH", "NATURAL", "NO", "NOT", "NOTNULL", "NOWAIT", "NULL", "NULLS", "OF", "OFFSET", "ON", "ONLY", "OR", "ORDER", "OUTER", "OVER", "PARTITION", "PLAN", "PRAGMA", "PRIMARY", "QUERY", "RAISE", "READ", "RECURSIVE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME", "REPLACE", "RESTRICT", "RETURNING", "RIGHT", "ROLLBACK", "ROW", "ROWID", "SAVEPOINT", "SELECT", "SET", "SHARE", "SHOW", "SKIP", "TABLE", "TEMP", "TEMPORARY", "THEN", "TO", "TRANSACTION", "TRIGGER", "UNION", "UNIQUE", "UPDATE", "USING", "VACUUM", "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WINDOW", "WITH", "WITHOUT", "reserved_words", "reserved_word_list", "reserved_critical_list", "comment", "comment_line", "comment_block", "comment_block_start", "comment_block_end", "comment_block_body", "block_body_nodes", "comment_block_feed", "o", "_TODO_"];
  var peg$descNames = [null, null, null, null, null, null, "Type Definition", null, "Custom Datatype Name", null, "Type Definition Arguments", null, null, "Null Literal", "Date Literal", "String Literal", "Single-quoted String Literal", null, "Blob Literal", "Typed literal (or bind parameter)", null, "Number Sign", null, null, null, "Decimal Literal", null, null, "Decimal Literal Exponent", "Hexidecimal Literal", null, null, "Bind Parameter", "Numbered Bind Parameter", null, "Named Bind Parameter", "TCL Bind Parameter", null, "EXISTS Expression", "EXISTS Keyword", "RAISE Expression", "RAISE Expression Arguments", "IGNORE Keyword", null, null, null, null, null, "PSQL-style cast", null, null, "COLLATE Expression", null, null, null, null, null, null, null, null, null, null, null, null, null, "CAST Expression", "Type Alias", "CASE Expression", null, "WHEN Clause", "ELSE Clause", null, null, "IS DISTINCT expression", "Comparison Expression", "ESCAPE Expression", "BETWEEN Expression", null, null, "IN Expression", null, null, null, null, "Expression List", null, null, "Function Call", "Function Call Arguments", null, "OVER clause", "Window name", "Window specification", null, "window partition clause", "Error Message", "Statement", "QUERY PLAN", "QUERY PLAN Keyword", null, "END Transaction Statement", "BEGIN Transaction Statement", null, null, "ROLLBACK Statement", "TO Clause", null, null, "SAVEPOINT Statement", "RELEASE Statement", "ALTER TABLE Statement", "ALTER TABLE Keyword", null, "RENAME TO Keyword", "ADD COLUMN Keyword", null, null, "WITH Clause", null, null, null, null, "Common Table Expression", null, null, null, null, null, null, "ATTACH Statement", null, "DETACH Statement", "VACUUM Statement", null, "ANALYZE Statement", null, "REINDEX Statement", null, "PRAGMA Statement", null, null, null, null, null, null, null, "SELECT Statement", "SELECT ... FOR locking clause", null, null, null, null, null, null, null, null, "WINDOW clause", null, null, null, "ORDER BY Clause", "LIMIT Clause", "OFFSET Clause", null, null, null, "Union Operation", null, null, "SELECT Results Clause", "SELECT Results Modifier", null, null, null, null, "FROM Clause", "WHERE Clause", "GROUP BY Clause", "HAVING Clause", null, null, null, null, null, null, "CROSS JOIN Operation", "JOIN Operation", null, null, null, null, null, null, null, "Qualified Table", "Qualified Table Identifier", "Qualfied Table Index", null, null, "SELECT Source", "Subquery", "Alias", "JOIN Operator", null, null, null, null, null, "JOIN Constraint", "Join ON Clause", "Join USING Clause", "VALUES Clause", null, null, "Ordering Expression", null, "Star", "Fallback Type", "INSERT Statement", "RETURNING clause", null, "INSERT Keyword", "REPLACE Keyword", "INSERT OR Modifier", null, "INTO Clause", "INTO Keyword", "VALUES Clause", "PostgreSQL INSERT ON CONFLICT clause", "PostgreSQL ON CONFLICT action", "PostgreSQL ON CONFLICT expression", "Column List", null, "Column Name", "VALUES Clause", "VALUES Keyword", null, null, "Wrapped Expression List", "DEFAULT VALUES Clause", "Compound Operator", "UNION Operator", null, "UPDATE Statement", "UPDATE Keyword", "UPDATE OR Modifier", "SET Clause", null, null, "Column Assignment", "UPDATE value expression", "DELETE Statement", "DELETE Keyword", "CREATE Statement", null, null, null, null, null, null, "CREATE TABLE Statement", null, null, "IF NOT EXISTS Modifier", null, "Table Definition", null, null, null, null, "Column Definition", null, "Column Datatype", null, null, "Column Constraint", null, "CONSTRAINT Name", null, "FOREIGN KEY Column Constraint", "PRIMARY KEY Column Constraint", "PRIMARY KEY Keyword", "AUTOINCREMENT Keyword", null, "UNIQUE Column Constraint", "NULL Column Constraint", "CHECK Column Constraint", "DEFAULT Column Constraint", null, "COLLATE Column Constraint", "Table Constraint", null, "CHECK Table Constraint", "PRIMARY KEY Table Constraint", null, "PRIMARY KEY Keyword", "UNIQUE Keyword", null, null, null, null, "Indexed Column", null, "Collation", null, "Column Direction", null, "ON CONFLICT Keyword", null, "FOREIGN KEY Table Constraint", "FOREIGN KEY Keyword", null, "REFERENCES Clause", null, null, "FOREIGN KEY Action Clause", null, "FOREIGN KEY Action", null, null, null, null, "DEFERRABLE Clause", null, null, "CREATE INDEX Statement", null, null, "ON Clause", "CREATE TRIGGER Statement", null, "Conditional Clause", null, null, "Conditional Action", null, null, null, null, null, "WHEN Clause", "Actions Clause", null, null, "CREATE VIEW Statement", null, null, null, "CREATE VIRTUAL TABLE Statement", null, null, "Module Arguments", null, null, null, null, "DROP Statement", "DROP Keyword", "DROP Type", "IF EXISTS Keyword", "Or", "Add", "Subtract", "Multiply", "Divide", "Modulo", "Shift Left", "Shift Right", "Logical AND", "Logical OR", "Less Than", "Greater Than", "Less Than Or Equal", "Greater Than Or Equal", "Equal", "Not Equal", "Not Equal", "PostgreSQL custom binary operarator", "IS", "Identifier", "Database Identifier", "Function Identifier", "Table Identifier", null, "Column Identifier", "value indirection", null, null, null, null, null, null, null, null, null, null, "Collation Identifier", "Savepoint Identifier", "Index Identifier", "Trigger Identifier", "View Identifier", "Pragma Identifier", "Variable Identifier", "CTE Identifier", null, "Table Constraint Identifier", "Column Constraint Identifier", "Datatype Name", "TEXT Datatype Name", "REAL Datatype Name", "DOUBLE Datatype Name", "NUMERIC Datatype Name", "INTEGER Datatype Name", null, "BLOB Datatype Name", null, null, null, null, null, null, null, null, null, null, null, "Open Bracket", "Close Bracket", "Open Parenthesis", "Close Parenthesis", "Comma", "Period", "Asterisk", "Question Mark", "Single Quote", "Double Quote", "Backtick", "Tilde", "Plus", "Minus", "Equal", "Ampersand", "Pipe", "Modulo", "Less Than", "Greater Than", "Exclamation", "Semicolon", "Colon", "Forward Slash", "Backslash", "Operator characters", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "Line Comment", "Block Comment", null, null, null, null, null, "Whitespace", null];

  var peg$tracer = "tracer" in options ? options.tracer : new peg$DefaultTracer();

  var peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleIndices)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleIndex = peg$startRuleIndices[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos];
    var p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos);
    var endPosDetails = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$decode(s) {
    return s.split("").map(function(ch) { return ch.charCodeAt(0) - 32; });
  }

  function peg$parseRule(index) {
    var bc = peg$bytecode[index];
    var ip = 0;
    var ips = [];
    var end = bc.length;
    var ends = [];
    var stack = [];
    var startPos = peg$currPos;
    var params;

    peg$tracer.trace({
      type: "rule.enter",
      rule: peg$ruleNames[index],
      description: peg$descNames[index],
      location: peg$computeLocation(startPos, startPos)
    });

    var key = peg$currPos * 606 + index;
    var cached = peg$resultsCache[key];

    if (cached) {
      peg$currPos = cached.nextPos;

    if (cached.result !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: peg$ruleNames[index],
        description: peg$descNames[index],
        result: cached.result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: peg$ruleNames[index],
        description: peg$descNames[index],
        location: peg$computeLocation(startPos, startPos)
      });
    }

      return cached.result;
    }

    while (true) {
      while (ip < end) {
        switch (bc[ip]) {
          case 0:
            stack.push(peg$consts[bc[ip + 1]]);
            ip += 2;
            break;

          case 1:
            stack.push(undefined);
            ip++;
            break;

          case 2:
            stack.push(null);
            ip++;
            break;

          case 3:
            stack.push(peg$FAILED);
            ip++;
            break;

          case 4:
            stack.push([]);
            ip++;
            break;

          case 5:
            stack.push(peg$currPos);
            ip++;
            break;

          case 6:
            stack.pop();
            ip++;
            break;

          case 7:
            peg$currPos = stack.pop();
            ip++;
            break;

          case 8:
            stack.length -= bc[ip + 1];
            ip += 2;
            break;

          case 9:
            stack.splice(-2, 1);
            ip++;
            break;

          case 10:
            stack[stack.length - 2].push(stack.pop());
            ip++;
            break;

          case 11:
            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
            ip += 2;
            break;

          case 12:
            stack.push(input.substring(stack.pop(), peg$currPos));
            ip++;
            break;

          case 13:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1]) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 14:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] === peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 15:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] !== peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 16:
            if (stack[stack.length - 1] !== peg$FAILED) {
              ends.push(end);
              ips.push(ip);

              end = ip + 2 + bc[ip + 1];
              ip += 2;
            } else {
              ip += 2 + bc[ip + 1];
            }

            break;

          case 17:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (input.length > peg$currPos) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 18:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 19:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 20:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 21:
            stack.push(input.substr(peg$currPos, bc[ip + 1]));
            peg$currPos += bc[ip + 1];
            ip += 2;
            break;

          case 22:
            stack.push(peg$consts[bc[ip + 1]]);
            peg$currPos += peg$consts[bc[ip + 1]].length;
            ip += 2;
            break;

          case 23:
            stack.push(peg$FAILED);
            if (peg$silentFails === 0) {
              peg$fail(peg$consts[bc[ip + 1]]);
            }
            ip += 2;
            break;

          case 24:
            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
            ip += 2;
            break;

          case 25:
            peg$savedPos = peg$currPos;
            ip++;
            break;

          case 26:
            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3])
              .map(function(p) { return stack[stack.length - 1 - p]; });

            stack.splice(
              stack.length - bc[ip + 2],
              bc[ip + 2],
              peg$consts[bc[ip + 1]].apply(null, params)
            );

            ip += 4 + bc[ip + 3];
            break;

          case 27:
            stack.push(peg$parseRule(bc[ip + 1]));
            ip += 2;
            break;

          case 28:
            peg$silentFails++;
            ip++;
            break;

          case 29:
            peg$silentFails--;
            ip++;
            break;

          default:
            throw new Error("Invalid opcode: " + bc[ip] + ".");
        }
      }

      if (ends.length > 0) {
        end = ends.pop();
        ip = ips.pop();
      } else {
        break;
      }
    }

    peg$resultsCache[key] = { nextPos: peg$currPos, result: stack[0] };

    if (stack[0] !== peg$FAILED) {
      peg$tracer.trace({
        type: "rule.match",
        rule: peg$ruleNames[index],
        description: peg$descNames[index],
        result: stack[0],
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: peg$ruleNames[index],
        description: peg$descNames[index],
        location: peg$computeLocation(startPos, startPos)
      });
    }

    return stack[0];
  }


    function makeArray(arr) {
      if (!isOkay(arr)) {
        return [];
      }
      return !Array.isArray(arr) ? [arr] : arr;
    }

    function isOkay(obj) {
      return obj != null;
    }

    function foldString(parts, glue = ' ') {
      const folded = parts
      .filter((part) => isOkay(part))
      .reduce((prev, cur) => {
        return `${prev}${nodeToString(cur)}${glue}`;
      }, '');
      return folded.trim();
    }

    function foldStringWord(parts) {
      return foldString(parts, '');
    }

    function foldStringKey(parts) {
      return foldString(parts).toLowerCase();
    }

    function flattenAll(arr) {
      return arr
      .filter((part) => isOkay(part))
      .reduce((prev, cur) => prev.concat(cur), []);
    }

    function unescape(str, quoteChar = '\'') {
      const re = new RegExp(`${quoteChar}{2}`, 'g');
      return nodeToString(str).replace(re, quoteChar);
    }

    function nodeToString(node = []) {
      return makeArray(node).join('');
    }

    /*
     * A text node has
     * - no leading or trailing whitespace
     */
    function textNode(node) {
      return nodeToString(node).trim();
    }

    function keyNode(node) {
      return textNode(node).toLowerCase();
    }

    function isArrayOkay(arr) {
      return Array.isArray(arr) && arr.length > 0 && isOkay(arr[0]);
    }

    function composeBinary(first, rest) {
      return rest
      .reduce((left, [ x, operation, y, right ]) => {
        return {
          'type': 'expression',
          'format': 'binary',
          'variant': 'operation',
          'operation': keyNode(operation),
          'left': left,
          'right': right
        };
      }, first);
    }


  peg$result = peg$parseRule(peg$startRuleIndex);

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  DefaultTracer: peg$DefaultTracer,
  parse: peg$parse
};
